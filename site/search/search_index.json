{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to the Wiki In this area, you will find useful information in order to help you during your DVID experience. You can navigate from menu or just use the search function. In case of issue, you can contact us here : issue@dvid.eu or chat with us. Have fun !","title":"Home"},{"location":"index.html#welcome-to-the-wiki","text":"In this area, you will find useful information in order to help you during your DVID experience. You can navigate from menu or just use the search function. In case of issue, you can contact us here : issue@dvid.eu or chat with us. Have fun !","title":"Welcome to the Wiki"},{"location":"cloud/index.html","text":"Cloud wiki In this area, you will find useful information for the cloud trainings. There will be pages about cloud specific protocols and tools. You can navigate from menu or just use the search function or with the following links. HTTP","title":"Cloud"},{"location":"cloud/index.html#cloud-wiki","text":"In this area, you will find useful information for the cloud trainings. There will be pages about cloud specific protocols and tools. You can navigate from menu or just use the search function or with the following links. HTTP","title":"Cloud wiki"},{"location":"cloud/http.html","text":"HTTP The Hypertext Transfer Protocol (HTTP) is a foundational protocol of the World Wide Web, enabling communication between clients (such as web browsers) and servers. It is an application-layer protocol designed for transmitting hypermedia documents, such as HTML, images, and videos. HTTP follows a request-response model, where clients send requests, and servers return responses. HTTP is stateless, meaning that each request from a client to a server is processed independently, with no memory of previous interactions unless explicitly managed using mechanisms like cookies or session storage. HTTP versions Here are the different HTTP versions with their release dates: HTTP/0.9 (1991): The first version, focused on transferring raw HTML content. Supported only GET requests and lacked headers or metadata. HTTP/1.0 (1996): Introduced metadata (headers), support for POST and HEAD methods, and status codes. Each request required a separate TCP connection. HTTP/1.1 (1997): Introduced persistent connections (keep-alive), chunked transfer encoding, and pipelining. Became the most widely used version for decades. HTTP/2 (2015): Focused on performance improvements, such as multiplexing (sending multiple requests over a single connection), header compression, and prioritization. HTTP/3 (2020): Builds upon HTTP/2 but replaces TCP with QUIC, a protocol based on UDP, to reduce latency and improve connection resilience. How HTTP Works HTTP operates on a client-server model: Client: Initiates the communication by sending an HTTP request. Examples: Web browsers (e.g., Chrome, Firefox), mobile apps, or API clients. Server: Processes the request and sends back an HTTP response containing the requested resource or an error message. Key Components of an HTTP Request An HTTP request consists of: Request Line: Specifies the HTTP method, target resource (URL), and protocol version (e.g., GET /index.html HTTP/1.1 ). Headers: Metadata about the request (e.g., User-Agent, Host, Accept ). Body: (Optional) Contains data sent with the request, such as form submissions or JSON payloads. Key Components of an HTTP Response An HTTP response consists of: Status Line: Indicates the protocol version, status code, and status message (e.g., HTTP/1.1 200 OK ). Headers: Metadata about the response (e.g., Content-Type, Content-Length, Server ). Body: The content being returned (e.g., HTML, JSON, or images). HTTP Methods HTTP defines several methods for different types of actions: GET : Retrieves data from a server. POST : Submits data to a server for processing (e.g., form data). PUT : Updates or replaces a resource on the server. DELETE : Deletes a resource on the server. HEAD : Similar to GET but retrieves only headers, not the body. OPTIONS : Describes the communication options for the target resource. PATCH : Partially updates a resource on the server. TRACE : Echoes the received request for diagnostic purposes. CONNECT : Establishes a tunnel for communication, often used with HTTPS. HTTP Status Codes HTTP uses standardized status codes to indicate the outcome of a request: 1xx: Informational 100 Continue: Request received, continue to send. 101 Switching Protocols: Server is switching to a new protocol. 2xx: Success 200 OK: Request succeeded. 201 Created: Resource successfully created. 204 No Content: Request succeeded, no content returned. 3xx: Redirection 301 Moved Permanently: Resource has a new permanent URL. 302 Found: Temporary redirection. 304 Not Modified: Resource not modified since last requested. 4xx: Client Errors 400 Bad Request: Invalid request syntax. 401 Unauthorized: Authentication required. 403 Forbidden: Access to the resource is denied. 404 Not Found: Resource not found. 5xx: Server Errors 500 Internal Server Error: Server encountered an error. 502 Bad Gateway: Invalid response from an upstream server. 503 Service Unavailable: Server is temporarily unavailable. Features of HTTP Here are the main features and \"charcteristics\" of HTTP: Statelessness : HTTP does not retain session information, simplifying protocol design. However, this requires mechanisms like cookies or tokens for session management. Flexible Content Handling : HTTP supports various content types (e.g., HTML, JSON, XML, images, videos) via the Content-Type header. Extensibility : Custom headers and methods can be added to support new functionalities. Security (HTTPS) : HTTPS is the secure version of HTTP that uses SSL/TLS to encrypt communication, ensuring confidentiality, integrity, and authentication. HTTP in everyday use As aleady said, the HTTP protocol is widely used on the web. Here are some examples of usage: Web Browsing : Browsers use HTTP to fetch and render web pages. APIs : RESTful APIs rely on HTTP for communication between clients and servers. This will be particularly explored in the cloud trainings . File Downloads : Many file transfer services use HTTP as the underlying protocol. IoT Devices : Internet-connected devices often use HTTP to send and receive data. This will be particularly explored in the trainings .","title":"HTTP"},{"location":"cloud/http.html#http","text":"The Hypertext Transfer Protocol (HTTP) is a foundational protocol of the World Wide Web, enabling communication between clients (such as web browsers) and servers. It is an application-layer protocol designed for transmitting hypermedia documents, such as HTML, images, and videos. HTTP follows a request-response model, where clients send requests, and servers return responses. HTTP is stateless, meaning that each request from a client to a server is processed independently, with no memory of previous interactions unless explicitly managed using mechanisms like cookies or session storage.","title":"HTTP"},{"location":"cloud/http.html#http-versions","text":"Here are the different HTTP versions with their release dates: HTTP/0.9 (1991): The first version, focused on transferring raw HTML content. Supported only GET requests and lacked headers or metadata. HTTP/1.0 (1996): Introduced metadata (headers), support for POST and HEAD methods, and status codes. Each request required a separate TCP connection. HTTP/1.1 (1997): Introduced persistent connections (keep-alive), chunked transfer encoding, and pipelining. Became the most widely used version for decades. HTTP/2 (2015): Focused on performance improvements, such as multiplexing (sending multiple requests over a single connection), header compression, and prioritization. HTTP/3 (2020): Builds upon HTTP/2 but replaces TCP with QUIC, a protocol based on UDP, to reduce latency and improve connection resilience.","title":"HTTP versions"},{"location":"cloud/http.html#how-http-works","text":"HTTP operates on a client-server model: Client: Initiates the communication by sending an HTTP request. Examples: Web browsers (e.g., Chrome, Firefox), mobile apps, or API clients. Server: Processes the request and sends back an HTTP response containing the requested resource or an error message.","title":"How HTTP Works"},{"location":"cloud/http.html#key-components-of-an-http-request","text":"An HTTP request consists of: Request Line: Specifies the HTTP method, target resource (URL), and protocol version (e.g., GET /index.html HTTP/1.1 ). Headers: Metadata about the request (e.g., User-Agent, Host, Accept ). Body: (Optional) Contains data sent with the request, such as form submissions or JSON payloads.","title":"Key Components of an HTTP Request"},{"location":"cloud/http.html#key-components-of-an-http-response","text":"An HTTP response consists of: Status Line: Indicates the protocol version, status code, and status message (e.g., HTTP/1.1 200 OK ). Headers: Metadata about the response (e.g., Content-Type, Content-Length, Server ). Body: The content being returned (e.g., HTML, JSON, or images).","title":"Key Components of an HTTP Response"},{"location":"cloud/http.html#http-methods","text":"HTTP defines several methods for different types of actions: GET : Retrieves data from a server. POST : Submits data to a server for processing (e.g., form data). PUT : Updates or replaces a resource on the server. DELETE : Deletes a resource on the server. HEAD : Similar to GET but retrieves only headers, not the body. OPTIONS : Describes the communication options for the target resource. PATCH : Partially updates a resource on the server. TRACE : Echoes the received request for diagnostic purposes. CONNECT : Establishes a tunnel for communication, often used with HTTPS.","title":"HTTP Methods"},{"location":"cloud/http.html#http-status-codes","text":"HTTP uses standardized status codes to indicate the outcome of a request: 1xx: Informational 100 Continue: Request received, continue to send. 101 Switching Protocols: Server is switching to a new protocol. 2xx: Success 200 OK: Request succeeded. 201 Created: Resource successfully created. 204 No Content: Request succeeded, no content returned. 3xx: Redirection 301 Moved Permanently: Resource has a new permanent URL. 302 Found: Temporary redirection. 304 Not Modified: Resource not modified since last requested. 4xx: Client Errors 400 Bad Request: Invalid request syntax. 401 Unauthorized: Authentication required. 403 Forbidden: Access to the resource is denied. 404 Not Found: Resource not found. 5xx: Server Errors 500 Internal Server Error: Server encountered an error. 502 Bad Gateway: Invalid response from an upstream server. 503 Service Unavailable: Server is temporarily unavailable.","title":"HTTP Status Codes"},{"location":"cloud/http.html#features-of-http","text":"Here are the main features and \"charcteristics\" of HTTP: Statelessness : HTTP does not retain session information, simplifying protocol design. However, this requires mechanisms like cookies or tokens for session management. Flexible Content Handling : HTTP supports various content types (e.g., HTML, JSON, XML, images, videos) via the Content-Type header. Extensibility : Custom headers and methods can be added to support new functionalities. Security (HTTPS) : HTTPS is the secure version of HTTP that uses SSL/TLS to encrypt communication, ensuring confidentiality, integrity, and authentication.","title":"Features of HTTP"},{"location":"cloud/http.html#http-in-everyday-use","text":"As aleady said, the HTTP protocol is widely used on the web. Here are some examples of usage: Web Browsing : Browsers use HTTP to fetch and render web pages. APIs : RESTful APIs rely on HTTP for communication between clients and servers. This will be particularly explored in the cloud trainings . File Downloads : Many file transfer services use HTTP as the underlying protocol. IoT Devices : Internet-connected devices often use HTTP to send and receive data. This will be particularly explored in the trainings .","title":"HTTP in everyday use"},{"location":"gateway/index.html","text":"Gateway wiki In this area, you will find useful information for the gateway trainings. There will be pages about gateway specific protocols and tools. You can navigate from menu or just use the search function or with the following links. MQTT","title":"Gateway"},{"location":"gateway/index.html#gateway-wiki","text":"In this area, you will find useful information for the gateway trainings. There will be pages about gateway specific protocols and tools. You can navigate from menu or just use the search function or with the following links. MQTT","title":"Gateway wiki"},{"location":"gateway/mqtt.html","text":"MQTT MQTT ( Message Queuing Telemetry Transport ) is a lightweight, publish-subscribe messaging protocol designed for constrained devices and low-bandwidth, high-latency, or unreliable networks. It is widely used in Internet of Things (IoT) applications for efficient communication between sensors, devices, and servers. Originally developed in 1999 by IBM, MQTT has become a popular protocol for IoT due to its simplicity, low resource requirements, and support for real-time messaging. MQTT versions MQTT has undergone several updates to improve its functionality and security: MQTT 3.1 (2010): The first widely adopted version, introducing key features like QoS. MQTT 3.1.1 (2014): Enhanced interoperability and clarified specifications. MQTT 5.0 (2019): Introduced major improvements, such as: User-defined properties for custom metadata. Negative acknowledgments (NACK) for rejected messages. Enhanced error reporting and scalability. How MQTT works MQTT operates on a publish-subscribe model, differing from the traditional client-server model of protocols like HTTP. Instead of a direct connection between devices, MQTT relies on a central broker to manage communication. Key components MQTT works with 3 key components: Broker: The central server that routes messages between devices. Examples of brokers include Eclipse Mosquitto, HiveMQ, and AWS IoT Core. Clients: Devices or applications that connect to the broker. Clients can: Publish messages to topics. Subscribe to topics to receive messages. Topics: Messages are categorized into topics (e.g., home/temperature) to organize communication. Clients subscribe to these topics to receive relevant data and can publish to topics. Typically, MQTT runs over TCP but it also supports WebSocket. The default ports are 1883 ( unencrypted ) and 8883 (TLS encrypted ). Similarly to HTTP, a Keep-Alive mechanism ensures clients remain connected to the broker. Workflow The MQTT workflow is divided into 3 phases: A client publishes a message to a topic (e.g., home/livingroom/temperature). The broker receives the message and forwards it to all clients that have subscribed to that topic. Subscribed clients receive the message in real time. Here is a simple example of a MQTT workflow: A temperature sensor publishes data to the topic home/livingroom/temperature, and a mobile app subscribes to the same topic to display temperature updates. The sensor sends a message: {\"temperature\": 22.5} to the broker. The broker forwards the message to all subscribers of the topic and the mobile app receives the message and updates the user interface. The mobile app can publish commands (e.g., turn_off ) to a topic like home/livingroom/thermostat/command, which the thermostat device subscribes to. Features of MQTT Here are the main features and \"charcteristics\" of MQTT: Lightweight and Efficient : Designed for devices with limited processing power and memory, MQTT uses minimal bandwidth. Publish-Subscribe Model : Decouples message senders (publishers) from receivers (subscribers), improving scalability. Quality of Service (QoS) : MQTT ensures reliable message delivery with three QoS levels: QoS 0: \"At most once\" delivery. Messages are sent without confirmation. QoS 1: \"At least once\" delivery. Messages are sent until acknowledged by the receiver. QoS 2: \"Exactly once\" delivery. Ensures the message is received only once, even if duplicates occur. Retained Messages : A published message can be retained by the broker, allowing new subscribers to receive the most recent message immediately. Will Messages : Allows clients to define a \"last will\" message that the broker sends if the client disconnects unexpectedly. Persistent Sessions : Supports persistent client sessions, enabling reconnection without losing subscription or message state. Security : While MQTT itself does not enforce security, encryption (via TLS) and authentication (via username/password or certificates) are commonly used. Security considerations with MQTT Since MQTT is commonly used in IoT, security is a major concern. Standard security practices include: Encryption : Use TLS/SSL to encrypt messages, ensuring confidentiality. Authentication : Username/password for basic authentication and certificates for mutual TLS authentication. Access Control : Brokers can enforce topic-level permissions, ensuring clients can only publish/subscribe to authorized topics. Firewalls : Restrict MQTT communication to trusted IP ranges and ports. MQTT in everyday use MQTT is ideal for scenarios where efficiency and reliability are critical, particularly in IoT environments: IoT and Smart Home Devices : Communicating sensor data (e.g., temperature, humidity). Controlling devices (e.g., turning on lights or adjusting thermostats). Industrial IoT (IIoT) : Monitoring equipment health and performance. Sending real-time alerts for machinery. Connected Vehicles : Exchanging data between vehicles and servers (e.g., GPS, speed). Fleet management systems. Healthcare : Wearable devices transmitting patient data (e.g., heart rate, blood pressure). Remote monitoring of medical equipment. Energy and Utilities : Smart grids for monitoring energy consumption. Communication between solar panels and central systems.","title":"MQTT"},{"location":"gateway/mqtt.html#mqtt","text":"MQTT ( Message Queuing Telemetry Transport ) is a lightweight, publish-subscribe messaging protocol designed for constrained devices and low-bandwidth, high-latency, or unreliable networks. It is widely used in Internet of Things (IoT) applications for efficient communication between sensors, devices, and servers. Originally developed in 1999 by IBM, MQTT has become a popular protocol for IoT due to its simplicity, low resource requirements, and support for real-time messaging.","title":"MQTT"},{"location":"gateway/mqtt.html#mqtt-versions","text":"MQTT has undergone several updates to improve its functionality and security: MQTT 3.1 (2010): The first widely adopted version, introducing key features like QoS. MQTT 3.1.1 (2014): Enhanced interoperability and clarified specifications. MQTT 5.0 (2019): Introduced major improvements, such as: User-defined properties for custom metadata. Negative acknowledgments (NACK) for rejected messages. Enhanced error reporting and scalability.","title":"MQTT versions"},{"location":"gateway/mqtt.html#how-mqtt-works","text":"MQTT operates on a publish-subscribe model, differing from the traditional client-server model of protocols like HTTP. Instead of a direct connection between devices, MQTT relies on a central broker to manage communication.","title":"How MQTT works"},{"location":"gateway/mqtt.html#key-components","text":"MQTT works with 3 key components: Broker: The central server that routes messages between devices. Examples of brokers include Eclipse Mosquitto, HiveMQ, and AWS IoT Core. Clients: Devices or applications that connect to the broker. Clients can: Publish messages to topics. Subscribe to topics to receive messages. Topics: Messages are categorized into topics (e.g., home/temperature) to organize communication. Clients subscribe to these topics to receive relevant data and can publish to topics. Typically, MQTT runs over TCP but it also supports WebSocket. The default ports are 1883 ( unencrypted ) and 8883 (TLS encrypted ). Similarly to HTTP, a Keep-Alive mechanism ensures clients remain connected to the broker.","title":"Key components"},{"location":"gateway/mqtt.html#workflow","text":"The MQTT workflow is divided into 3 phases: A client publishes a message to a topic (e.g., home/livingroom/temperature). The broker receives the message and forwards it to all clients that have subscribed to that topic. Subscribed clients receive the message in real time. Here is a simple example of a MQTT workflow: A temperature sensor publishes data to the topic home/livingroom/temperature, and a mobile app subscribes to the same topic to display temperature updates. The sensor sends a message: {\"temperature\": 22.5} to the broker. The broker forwards the message to all subscribers of the topic and the mobile app receives the message and updates the user interface. The mobile app can publish commands (e.g., turn_off ) to a topic like home/livingroom/thermostat/command, which the thermostat device subscribes to.","title":"Workflow"},{"location":"gateway/mqtt.html#features-of-mqtt","text":"Here are the main features and \"charcteristics\" of MQTT: Lightweight and Efficient : Designed for devices with limited processing power and memory, MQTT uses minimal bandwidth. Publish-Subscribe Model : Decouples message senders (publishers) from receivers (subscribers), improving scalability. Quality of Service (QoS) : MQTT ensures reliable message delivery with three QoS levels: QoS 0: \"At most once\" delivery. Messages are sent without confirmation. QoS 1: \"At least once\" delivery. Messages are sent until acknowledged by the receiver. QoS 2: \"Exactly once\" delivery. Ensures the message is received only once, even if duplicates occur. Retained Messages : A published message can be retained by the broker, allowing new subscribers to receive the most recent message immediately. Will Messages : Allows clients to define a \"last will\" message that the broker sends if the client disconnects unexpectedly. Persistent Sessions : Supports persistent client sessions, enabling reconnection without losing subscription or message state. Security : While MQTT itself does not enforce security, encryption (via TLS) and authentication (via username/password or certificates) are commonly used.","title":"Features of MQTT"},{"location":"gateway/mqtt.html#security-considerations-with-mqtt","text":"Since MQTT is commonly used in IoT, security is a major concern. Standard security practices include: Encryption : Use TLS/SSL to encrypt messages, ensuring confidentiality. Authentication : Username/password for basic authentication and certificates for mutual TLS authentication. Access Control : Brokers can enforce topic-level permissions, ensuring clients can only publish/subscribe to authorized topics. Firewalls : Restrict MQTT communication to trusted IP ranges and ports.","title":"Security considerations with MQTT"},{"location":"gateway/mqtt.html#mqtt-in-everyday-use","text":"MQTT is ideal for scenarios where efficiency and reliability are critical, particularly in IoT environments: IoT and Smart Home Devices : Communicating sensor data (e.g., temperature, humidity). Controlling devices (e.g., turning on lights or adjusting thermostats). Industrial IoT (IIoT) : Monitoring equipment health and performance. Sending real-time alerts for machinery. Connected Vehicles : Exchanging data between vehicles and servers (e.g., GPS, speed). Fleet management systems. Healthcare : Wearable devices transmitting patient data (e.g., heart rate, blood pressure). Remote monitoring of medical equipment. Energy and Utilities : Smart grids for monitoring energy consumption. Communication between solar panels and central systems.","title":"MQTT in everyday use"},{"location":"hardware/index.html","text":"Hardware wiki In this area, you will find useful information for the hardware trainings. There will be pages about hardware specific protocols and tools. You can navigate from menu or just use the search function or with the following links. Bluetooth UART","title":"Hardware"},{"location":"hardware/index.html#hardware-wiki","text":"In this area, you will find useful information for the hardware trainings. There will be pages about hardware specific protocols and tools. You can navigate from menu or just use the search function or with the following links. Bluetooth UART","title":"Hardware wiki"},{"location":"hardware/bluetooth.html","text":"Bluetooth Bluetooth is a short-range wireless communication protocol designed for exchanging data between devices over a short distance using radio waves. It operates in the 2.4 GHz ISM (Industrial, Scientific, and Medical) band and is widely used for connecting devices such as smartphones, laptops, headphones, wearables, and IoT devices. Originally developed in 1994 by Ericsson, Bluetooth has evolved into a versatile protocol for both data transfer and low-power wireless communication. Bluetooth versions Bluetooth has undergone several updates to improve its functionality and security: 1.0 and 1.1 (1999): Initial release with basic functionality. 2.0 + EDR (2004): Introduced Enhanced Data Rate (3 Mbps). 3.0 + HS (2009): Added support for faster transfer (up to 24 Mbps) using Wi-Fi. 4.0 (2010): Introduced Bluetooth Low Energy (BLE). 4.2 (2014): Improved security and support for IPv6. 5.0 (2016): Increased range (up to 240m), speed (2 Mbps), and broadcasting capacity. 5.1 (2019): Introduced direction finding for location-based services. 5.2 (2020): Enhanced audio with LE Audio and support for Isochronous Channels. 5.3 (2021): Improved energy efficiency and performance. How Bluetooth works Bluetooth operates on the principle of device pairing and communication over short distances, typically up to 10 meters (33 feet) for standard Bluetooth and up to 100 meters (328 feet) for Bluetooth Class 1 devices. Key components Bluetooth presents with 3 key components: Devices: Central Device (Master): Initiates and manages communication (e.g., a smartphone). Peripheral Device (Slave): Responds to the central device (e.g., a wireless speaker or fitness tracker). Piconet: A small network of devices connected via Bluetooth. One central device can connect to up to 7 active peripherals. Frequency Hopping: Bluetooth divides the 2.4 GHz band into 79 channels and uses frequency hopping spread spectrum (FHSS) to switch between channels up to 1600 times per second. This reduces interference and improves reliability. Bluetooth uses standardized profiles to define how devices communicate for specific use cases. Here are some popular profiles include: HFP (Hands-Free Profile): Used for hands-free calling (e.g., in car systems). A2DP (Advanced Audio Distribution Profile): Transmits high-quality audio. HID (Human Interface Device Profile): For keyboards, mice, and game controllers. SPP (Serial Port Profile): Emulates serial communication over Bluetooth. GATT (Generic Attribute Profile): Used by Bluetooth Low Energy (BLE) devices. Workflow The Bluetooth workflow is divided in two steps: the discovery and pairing, and the communication phase. Device discovery and pairing Here are the first phases of device discovery and pairing: Discovery: Devices scan for others within range. A device may be in discoverable mode to advertise its presence. Pairing: Establishes a secure link between devices using methods such as: PIN codes. Numeric Comparison (user verifies matching codes). Just Works (no authentication for low-security use cases). Bonding: After pairing, devices store a long-term key to reconnect without re-pairing. Communication phase After the pairing phase, the devices can start to communicate: Connection Establishment: The central device initiates a connection to a peripheral. Data Exchange: Devices communicate using profiles and protocols (e.g., audio streaming or file transfer). Disconnection: Devices can terminate the connection when the communication is complete. Security considerations with Bluetooth Since Bluetooth is commonly used in IoT, security is a major concern. Standard security practices include: Encryption : Uses AES encryption to protect data during transmission. Authentication : Pairing methods prevent unauthorized devices from connecting. Secure Simple Pairing (SSP) : Modern Bluetooth versions use SSP for stronger security during pairing. Passive Eavesdropping Protection : Frequency hopping minimizes the risk of interception. Bluetooth in everyday use As aleady said, the Bluetooth protocol is widely used. Here are some examples of usage: Audio Devices : Wireless headphones, speakers, and hearing aids use profiles like A2DP and HFP. IoT Devices : Smart home devices (e.g., locks, thermostats, and lights). Wearables : Fitness trackers and smartwatches for health monitoring and notifications. Proximity Beacons : Location-based services like indoor navigation or retail promotions. File Transfer : Sending files between phones, tablets, or computers. Game Controllers : Bluetooth HID profile for connecting keyboards, mice, and controllers.","title":"Bluetooth"},{"location":"hardware/bluetooth.html#bluetooth","text":"Bluetooth is a short-range wireless communication protocol designed for exchanging data between devices over a short distance using radio waves. It operates in the 2.4 GHz ISM (Industrial, Scientific, and Medical) band and is widely used for connecting devices such as smartphones, laptops, headphones, wearables, and IoT devices. Originally developed in 1994 by Ericsson, Bluetooth has evolved into a versatile protocol for both data transfer and low-power wireless communication.","title":"Bluetooth"},{"location":"hardware/bluetooth.html#bluetooth-versions","text":"Bluetooth has undergone several updates to improve its functionality and security: 1.0 and 1.1 (1999): Initial release with basic functionality. 2.0 + EDR (2004): Introduced Enhanced Data Rate (3 Mbps). 3.0 + HS (2009): Added support for faster transfer (up to 24 Mbps) using Wi-Fi. 4.0 (2010): Introduced Bluetooth Low Energy (BLE). 4.2 (2014): Improved security and support for IPv6. 5.0 (2016): Increased range (up to 240m), speed (2 Mbps), and broadcasting capacity. 5.1 (2019): Introduced direction finding for location-based services. 5.2 (2020): Enhanced audio with LE Audio and support for Isochronous Channels. 5.3 (2021): Improved energy efficiency and performance.","title":"Bluetooth versions"},{"location":"hardware/bluetooth.html#how-bluetooth-works","text":"Bluetooth operates on the principle of device pairing and communication over short distances, typically up to 10 meters (33 feet) for standard Bluetooth and up to 100 meters (328 feet) for Bluetooth Class 1 devices.","title":"How Bluetooth works"},{"location":"hardware/bluetooth.html#key-components","text":"Bluetooth presents with 3 key components: Devices: Central Device (Master): Initiates and manages communication (e.g., a smartphone). Peripheral Device (Slave): Responds to the central device (e.g., a wireless speaker or fitness tracker). Piconet: A small network of devices connected via Bluetooth. One central device can connect to up to 7 active peripherals. Frequency Hopping: Bluetooth divides the 2.4 GHz band into 79 channels and uses frequency hopping spread spectrum (FHSS) to switch between channels up to 1600 times per second. This reduces interference and improves reliability. Bluetooth uses standardized profiles to define how devices communicate for specific use cases. Here are some popular profiles include: HFP (Hands-Free Profile): Used for hands-free calling (e.g., in car systems). A2DP (Advanced Audio Distribution Profile): Transmits high-quality audio. HID (Human Interface Device Profile): For keyboards, mice, and game controllers. SPP (Serial Port Profile): Emulates serial communication over Bluetooth. GATT (Generic Attribute Profile): Used by Bluetooth Low Energy (BLE) devices.","title":"Key components"},{"location":"hardware/bluetooth.html#workflow","text":"The Bluetooth workflow is divided in two steps: the discovery and pairing, and the communication phase.","title":"Workflow"},{"location":"hardware/bluetooth.html#device-discovery-and-pairing","text":"Here are the first phases of device discovery and pairing: Discovery: Devices scan for others within range. A device may be in discoverable mode to advertise its presence. Pairing: Establishes a secure link between devices using methods such as: PIN codes. Numeric Comparison (user verifies matching codes). Just Works (no authentication for low-security use cases). Bonding: After pairing, devices store a long-term key to reconnect without re-pairing.","title":"Device discovery and pairing"},{"location":"hardware/bluetooth.html#communication-phase","text":"After the pairing phase, the devices can start to communicate: Connection Establishment: The central device initiates a connection to a peripheral. Data Exchange: Devices communicate using profiles and protocols (e.g., audio streaming or file transfer). Disconnection: Devices can terminate the connection when the communication is complete.","title":"Communication phase"},{"location":"hardware/bluetooth.html#security-considerations-with-bluetooth","text":"Since Bluetooth is commonly used in IoT, security is a major concern. Standard security practices include: Encryption : Uses AES encryption to protect data during transmission. Authentication : Pairing methods prevent unauthorized devices from connecting. Secure Simple Pairing (SSP) : Modern Bluetooth versions use SSP for stronger security during pairing. Passive Eavesdropping Protection : Frequency hopping minimizes the risk of interception.","title":"Security considerations with Bluetooth"},{"location":"hardware/bluetooth.html#bluetooth-in-everyday-use","text":"As aleady said, the Bluetooth protocol is widely used. Here are some examples of usage: Audio Devices : Wireless headphones, speakers, and hearing aids use profiles like A2DP and HFP. IoT Devices : Smart home devices (e.g., locks, thermostats, and lights). Wearables : Fitness trackers and smartwatches for health monitoring and notifications. Proximity Beacons : Location-based services like indoor navigation or retail promotions. File Transfer : Sending files between phones, tablets, or computers. Game Controllers : Bluetooth HID profile for connecting keyboards, mice, and controllers.","title":"Bluetooth in everyday use"},{"location":"hardware/uart.html","text":"UART UART ( Universal Asynchronous Receiver-Transmitter ) is a hardware communication protocol used for asynchronous serial communication between electronic devices. Unlike SPI and I2C, which are synchronous protocols, UART does not require a clock signal. Instead, it uses a predefined baud rate to synchronize data transmission. UART is commonly used in embedded systems, microcontrollers, and communication modules such as GPS, Bluetooth, and Wi-Fi modules. How UART works UART enables two-way communication between two devices over two wires: TX (Transmit): Sends data. RX (Receive): Receives data. Each device's TX line is connected to the RX line of the other device. Unlike synchronous protocols, UART does not use a clock signal. Instead, both devices agree on a common baud rate (data transmission speed). Data is transmitted one bit at a time in a structured format. Each UART transmission consists of a frame that includes: Start Bit (1 bit): A 0 (low voltage) is sent to indicate the beginning of data transmission. Data Bits (5\u20139 bits, typically 8 bits): The actual data being transmitted. Parity Bit (1 bit, optional): Used for error detection (even or odd parity). Stop Bit (1\u20132 bits): A 1 (high voltage) to signal the end of the transmission. The baud rate defines the transmission speed in bits per second (bps). Common baud rates include: 9600 bps (default for many devices) 115200 bps (commonly used for fast communication) 57600, 38400, 19200, 4800 bps, etc. Both devices must use the same baud rate to communicate properly. Features of UART Here are some interesting and advanced features of UART: DMA (Direct Memory Access) : Reduces CPU load by handling large data transmissions automatically. Hardware Flow Control (RTS/CTS) : Additional Request to Send (RTS) and Clear to Send (CTS) signals prevent buffer overflows. Half-Duplex Mode : Uses a single wire for bidirectional communication (one direction at a time). Software Serial (Bit-Banging) : Allows UART emulation on microcontrollers without dedicated UART hardware. UART in everyday use Embedded Systems : Communication between microcontrollers (e.g., Arduino, Raspberry Pi, ESP32). GPS Modules : Transmitting location data over UART. Bluetooth Modules (HC-05, HC-06) : Serial communication with wireless devices. Debugging & Serial Monitoring : Used for debugging with tools like the Serial Monitor in Arduino. Industrial Applications : Communicating with sensors, motor controllers, and other peripherals.","title":"UART"},{"location":"hardware/uart.html#uart","text":"UART ( Universal Asynchronous Receiver-Transmitter ) is a hardware communication protocol used for asynchronous serial communication between electronic devices. Unlike SPI and I2C, which are synchronous protocols, UART does not require a clock signal. Instead, it uses a predefined baud rate to synchronize data transmission. UART is commonly used in embedded systems, microcontrollers, and communication modules such as GPS, Bluetooth, and Wi-Fi modules.","title":"UART"},{"location":"hardware/uart.html#how-uart-works","text":"UART enables two-way communication between two devices over two wires: TX (Transmit): Sends data. RX (Receive): Receives data. Each device's TX line is connected to the RX line of the other device. Unlike synchronous protocols, UART does not use a clock signal. Instead, both devices agree on a common baud rate (data transmission speed). Data is transmitted one bit at a time in a structured format. Each UART transmission consists of a frame that includes: Start Bit (1 bit): A 0 (low voltage) is sent to indicate the beginning of data transmission. Data Bits (5\u20139 bits, typically 8 bits): The actual data being transmitted. Parity Bit (1 bit, optional): Used for error detection (even or odd parity). Stop Bit (1\u20132 bits): A 1 (high voltage) to signal the end of the transmission. The baud rate defines the transmission speed in bits per second (bps). Common baud rates include: 9600 bps (default for many devices) 115200 bps (commonly used for fast communication) 57600, 38400, 19200, 4800 bps, etc. Both devices must use the same baud rate to communicate properly.","title":"How UART works"},{"location":"hardware/uart.html#features-of-uart","text":"Here are some interesting and advanced features of UART: DMA (Direct Memory Access) : Reduces CPU load by handling large data transmissions automatically. Hardware Flow Control (RTS/CTS) : Additional Request to Send (RTS) and Clear to Send (CTS) signals prevent buffer overflows. Half-Duplex Mode : Uses a single wire for bidirectional communication (one direction at a time). Software Serial (Bit-Banging) : Allows UART emulation on microcontrollers without dedicated UART hardware.","title":"Features of UART"},{"location":"hardware/uart.html#uart-in-everyday-use","text":"Embedded Systems : Communication between microcontrollers (e.g., Arduino, Raspberry Pi, ESP32). GPS Modules : Transmitting location data over UART. Bluetooth Modules (HC-05, HC-06) : Serial communication with wireless devices. Debugging & Serial Monitoring : Used for debugging with tools like the Serial Monitor in Arduino. Industrial Applications : Communicating with sensors, motor controllers, and other peripherals.","title":"UART in everyday use"},{"location":"hardware/wifi.html","text":"Wi-Fi Wi-Fi is a family of wireless network protocols based on the IEEE 802.11 standards, commonly used for local area networking of devices. It is a trademark of the Wi-Fi Alliance, which restricts the use of the term \"Wi-Fi Certified\" to products that successfully complete interoperability certification testing. Since 2019, more than 3.05 billion Wi-Fi-enabled devices are shipped globally each year. Wi-Fi Versions Wi-Fi has evolved through several IEEE standardized versions: Original (1997) : First specification with FHSS (1 Mbps) and DSSS (1-2 Mbps) methods in the 2.4 GHz band. 802.11b (1999) - Wi-Fi 1 : First major standard, speeds up to 11 Mbps in the 2.4 GHz band. 802.11a (1999) - Wi-Fi 2 : Used OFDM, speeds up to 54 Mbps in the 5 GHz band. 802.11g (2003) - Wi-Fi 3 : Increased speed to 54 Mbps in the 2.4 GHz band using OFDM. 802.11n (2009) - Wi-Fi 4 : Used multiple antennas for speeds up to 450 Mbps, compatible with both 2.4 GHz and 5 GHz bands. 802.11ac (2012) - Wi-Fi 5 : Operates in the 5 GHz band with gigabit speeds. 802.11ax (2021) - Wi-Fi 6 : Works in both 2.4 GHz and 5 GHz bands with multi-gigabit speeds. Wi-Fi 6E adds the 6 GHz band. 802.11be (2023) - Wi-Fi 7 : Operates in the same three bands as Wi-Fi 6E, with expected speeds up to 40 Gbps. How Wi-Fi Works Wi-Fi works by sending data packets via radio waves over different channels. Devices communicate by modulating and demodulating carrier waves. Key Components Wi-Fi Stations : All devices equipped with Wi-Fi capabilities. Access Points : Devices that allow stations to connect to a wired network. Channels : Subdivisions of radio bands used for transmission. MAC Addresses : Unique 48-bit identifiers programmed into each station. Communication Stack Wi-Fi is part of the IEEE 802 family of protocols. Data is organized into 802.11 frames at the data link layer, similar to Ethernet frames but with additional address fields needed for wireless communication. The MAC and physical layer specifications are the technical rules that determine how Wi-Fi devices transmit and receive radio signals across the 2.4, 5, and 6 GHz frequency bands. Transmission Mechanism Wi-Fi uses CSMA/CA (Carrier-Sense Multiple Access with Collision Avoidance) to manage how devices share the wireless medium. Before transmitting, devices check if the channel is clear to avoid collisions. Channels operate in half-duplex mode, meaning devices can either transmit or receive at one time, but not both simultaneously. Multiple networks can share the same channel, though this may reduce performance. Wi-Fi Channels Wi-Fi channels are specific frequency ranges within each band that devices use to communicate. Channel Basics Think of Wi-Fi channels like lanes on a highway - they allow multiple devices to communicate without interfering with each other. Each Wi-Fi band contains multiple channels: 2.4 GHz band : Contains 11-14 channels (depending on country) 5 GHz band : Contains 24+ non-overlapping channels 6 GHz band : Contains up to 59 channels (newest addition) Channel Numbering and Characteristics 2.4 GHz Band Numbered from 1 to 14 (most countries use 1-11 or 1-13) Only channels 1, 6, and 11 don't overlap with each other Provides better range but more interference from other devices 5 GHz Band Numbered non-consecutively (36, 40, 44, 48, etc.) All channels are non-overlapping Better speeds but shorter range than 2.4 GHz 6 GHz Band Newest band with many available channels Highest speeds but shortest range Less congestion than other bands Channel Width Channel width determines how much of the frequency spectrum a connection uses: 20 MHz : Standard width 40 MHz : Twice as wide, potentially twice as fast 80 MHz : Four times as wide 160 MHz : Eight times as wide Wider channels provide faster speeds but are more susceptible to interference. Key Wi-Fi Terminology Understanding the following terms is essential for effective network management and troubleshooting: BSSID (Basic Service Set Identifier) The BSSID is the MAC physical address of the access point or wireless router used to connect to the Wi-Fi network. It's a unique 48-bit identifier that distinguishes between multiple access points within a wireless network. Key points about BSSID: - It's based on the MAC address of the access point's wireless adapter - Each access point in a network has its own unique BSSID - Users typically don't notice when their device switches from one BSSID to another SSID (Service Set Identifier) The SSID is the name of a wireless network that users see when searching for available Wi-Fi connections. It's a human-readable identifier that allows users to distinguish between different networks. Key points about SSID: - Can be up to 32 octets (characters) long - Typically displayed in natural language (like \"HomeWiFi\" or \"OfficeNetwork\") - Broadcast by access points to announce the presence of a network - Multiple access points can share the same SSID in larger networks ESSID (Extended Service Set Identifier) The ESSID is essentially the SSID used in a network with multiple access points. It represents the entire Wi-Fi network rather than an individual access point. Key points about ESSID: - Often used interchangeably with SSID - Helps create a unified network experience across different physical locations Range and Performance Wi-Fi radio bands work best in line-of-sight conditions. Common obstacles like walls can significantly reduce range, but this also helps minimize interference between different networks in crowded environments. The range of an access point is about 20 meters (66 feet) indoors, while some access points claim a range of up to 150 meters (490 feet) outdoors. Over time, the speed and spectral efficiency of Wi-Fi have increased. As of 2019, some versions of Wi-Fi, operating on suitable hardware at short range, can achieve speeds of 9.6 Gbit/s. Channel Selection Tips For 2.4 GHz networks, stick to channels 1, 6, or 11 to avoid overlap Use channel scanning tools to identify the least congested channels in your area Consider using the 5 GHz band in dense environments for less interference Modern routers can automatically select channels, but manual selection may be better in high-density environments Security Considerations Securing Wi-Fi networks is essential to protect your data. Here are the main measures to take: Change Default Passwords : First line of defense to protect your network, change both the default administrator password and the default SSID name to something unique. Implement Strong Encryption : Use WPA3 protocol (currently the strongest) to encrypt information transmitted between routers and wireless devices. Segment Your Network : Separate sensitive devices or data from the rest of your network for additional protection, especially for IoT devices. Set Up a Guest Network : Create a separate network for visitors to keep them isolated from your main network and sensitive devices. Keep Router Firmware Updated : Regularly update your router's software to patch security vulnerabilities.","title":"Wi-Fi"},{"location":"hardware/wifi.html#wi-fi","text":"Wi-Fi is a family of wireless network protocols based on the IEEE 802.11 standards, commonly used for local area networking of devices. It is a trademark of the Wi-Fi Alliance, which restricts the use of the term \"Wi-Fi Certified\" to products that successfully complete interoperability certification testing. Since 2019, more than 3.05 billion Wi-Fi-enabled devices are shipped globally each year.","title":"Wi-Fi"},{"location":"hardware/wifi.html#wi-fi-versions","text":"Wi-Fi has evolved through several IEEE standardized versions: Original (1997) : First specification with FHSS (1 Mbps) and DSSS (1-2 Mbps) methods in the 2.4 GHz band. 802.11b (1999) - Wi-Fi 1 : First major standard, speeds up to 11 Mbps in the 2.4 GHz band. 802.11a (1999) - Wi-Fi 2 : Used OFDM, speeds up to 54 Mbps in the 5 GHz band. 802.11g (2003) - Wi-Fi 3 : Increased speed to 54 Mbps in the 2.4 GHz band using OFDM. 802.11n (2009) - Wi-Fi 4 : Used multiple antennas for speeds up to 450 Mbps, compatible with both 2.4 GHz and 5 GHz bands. 802.11ac (2012) - Wi-Fi 5 : Operates in the 5 GHz band with gigabit speeds. 802.11ax (2021) - Wi-Fi 6 : Works in both 2.4 GHz and 5 GHz bands with multi-gigabit speeds. Wi-Fi 6E adds the 6 GHz band. 802.11be (2023) - Wi-Fi 7 : Operates in the same three bands as Wi-Fi 6E, with expected speeds up to 40 Gbps.","title":"Wi-Fi Versions"},{"location":"hardware/wifi.html#how-wi-fi-works","text":"Wi-Fi works by sending data packets via radio waves over different channels. Devices communicate by modulating and demodulating carrier waves.","title":"How Wi-Fi Works"},{"location":"hardware/wifi.html#key-components","text":"Wi-Fi Stations : All devices equipped with Wi-Fi capabilities. Access Points : Devices that allow stations to connect to a wired network. Channels : Subdivisions of radio bands used for transmission. MAC Addresses : Unique 48-bit identifiers programmed into each station.","title":"Key Components"},{"location":"hardware/wifi.html#communication-stack","text":"Wi-Fi is part of the IEEE 802 family of protocols. Data is organized into 802.11 frames at the data link layer, similar to Ethernet frames but with additional address fields needed for wireless communication. The MAC and physical layer specifications are the technical rules that determine how Wi-Fi devices transmit and receive radio signals across the 2.4, 5, and 6 GHz frequency bands.","title":"Communication Stack"},{"location":"hardware/wifi.html#transmission-mechanism","text":"Wi-Fi uses CSMA/CA (Carrier-Sense Multiple Access with Collision Avoidance) to manage how devices share the wireless medium. Before transmitting, devices check if the channel is clear to avoid collisions. Channels operate in half-duplex mode, meaning devices can either transmit or receive at one time, but not both simultaneously. Multiple networks can share the same channel, though this may reduce performance.","title":"Transmission Mechanism"},{"location":"hardware/wifi.html#wi-fi-channels","text":"Wi-Fi channels are specific frequency ranges within each band that devices use to communicate.","title":"Wi-Fi Channels"},{"location":"hardware/wifi.html#channel-basics","text":"Think of Wi-Fi channels like lanes on a highway - they allow multiple devices to communicate without interfering with each other. Each Wi-Fi band contains multiple channels: 2.4 GHz band : Contains 11-14 channels (depending on country) 5 GHz band : Contains 24+ non-overlapping channels 6 GHz band : Contains up to 59 channels (newest addition)","title":"Channel Basics"},{"location":"hardware/wifi.html#channel-numbering-and-characteristics","text":"","title":"Channel Numbering and Characteristics"},{"location":"hardware/wifi.html#24-ghz-band","text":"Numbered from 1 to 14 (most countries use 1-11 or 1-13) Only channels 1, 6, and 11 don't overlap with each other Provides better range but more interference from other devices","title":"2.4 GHz Band"},{"location":"hardware/wifi.html#5-ghz-band","text":"Numbered non-consecutively (36, 40, 44, 48, etc.) All channels are non-overlapping Better speeds but shorter range than 2.4 GHz","title":"5 GHz Band"},{"location":"hardware/wifi.html#6-ghz-band","text":"Newest band with many available channels Highest speeds but shortest range Less congestion than other bands","title":"6 GHz Band"},{"location":"hardware/wifi.html#channel-width","text":"Channel width determines how much of the frequency spectrum a connection uses: 20 MHz : Standard width 40 MHz : Twice as wide, potentially twice as fast 80 MHz : Four times as wide 160 MHz : Eight times as wide Wider channels provide faster speeds but are more susceptible to interference.","title":"Channel Width"},{"location":"hardware/wifi.html#key-wi-fi-terminology","text":"Understanding the following terms is essential for effective network management and troubleshooting:","title":"Key Wi-Fi Terminology"},{"location":"hardware/wifi.html#bssid-basic-service-set-identifier","text":"The BSSID is the MAC physical address of the access point or wireless router used to connect to the Wi-Fi network. It's a unique 48-bit identifier that distinguishes between multiple access points within a wireless network. Key points about BSSID: - It's based on the MAC address of the access point's wireless adapter - Each access point in a network has its own unique BSSID - Users typically don't notice when their device switches from one BSSID to another","title":"BSSID (Basic Service Set Identifier)"},{"location":"hardware/wifi.html#ssid-service-set-identifier","text":"The SSID is the name of a wireless network that users see when searching for available Wi-Fi connections. It's a human-readable identifier that allows users to distinguish between different networks. Key points about SSID: - Can be up to 32 octets (characters) long - Typically displayed in natural language (like \"HomeWiFi\" or \"OfficeNetwork\") - Broadcast by access points to announce the presence of a network - Multiple access points can share the same SSID in larger networks","title":"SSID (Service Set Identifier)"},{"location":"hardware/wifi.html#essid-extended-service-set-identifier","text":"The ESSID is essentially the SSID used in a network with multiple access points. It represents the entire Wi-Fi network rather than an individual access point. Key points about ESSID: - Often used interchangeably with SSID - Helps create a unified network experience across different physical locations","title":"ESSID (Extended Service Set Identifier)"},{"location":"hardware/wifi.html#range-and-performance","text":"Wi-Fi radio bands work best in line-of-sight conditions. Common obstacles like walls can significantly reduce range, but this also helps minimize interference between different networks in crowded environments. The range of an access point is about 20 meters (66 feet) indoors, while some access points claim a range of up to 150 meters (490 feet) outdoors. Over time, the speed and spectral efficiency of Wi-Fi have increased. As of 2019, some versions of Wi-Fi, operating on suitable hardware at short range, can achieve speeds of 9.6 Gbit/s.","title":"Range and Performance"},{"location":"hardware/wifi.html#channel-selection-tips","text":"For 2.4 GHz networks, stick to channels 1, 6, or 11 to avoid overlap Use channel scanning tools to identify the least congested channels in your area Consider using the 5 GHz band in dense environments for less interference Modern routers can automatically select channels, but manual selection may be better in high-density environments","title":"Channel Selection Tips"},{"location":"hardware/wifi.html#security-considerations","text":"Securing Wi-Fi networks is essential to protect your data. Here are the main measures to take: Change Default Passwords : First line of defense to protect your network, change both the default administrator password and the default SSID name to something unique. Implement Strong Encryption : Use WPA3 protocol (currently the strongest) to encrypt information transmitted between routers and wireless devices. Segment Your Network : Separate sensitive devices or data from the rest of your network for additional protection, especially for IoT devices. Set Up a Guest Network : Create a separate network for visitors to keep them isolated from your main network and sensitive devices. Keep Router Firmware Updated : Regularly update your router's software to patch security vulnerabilities.","title":"Security Considerations"},{"location":"policy/index.html","text":"Policy In this area, you will find useful information for the policy trainings.","title":"Policy"},{"location":"policy/index.html#policy","text":"In this area, you will find useful information for the policy trainings.","title":"Policy"},{"location":"tools/index.html","text":"Welcome to the tools area In this area, you will find useful information about all the tools presented and used during the different trainings. Summary Nmap Curl Docker","title":"Welcome to the tools area"},{"location":"tools/index.html#welcome-to-the-tools-area","text":"In this area, you will find useful information about all the tools presented and used during the different trainings.","title":"Welcome to the tools area"},{"location":"tools/index.html#summary","text":"Nmap Curl Docker","title":"Summary"},{"location":"tools/aircrack-ng.html","text":"Aircrack-ng Aircrack-ng is a network software suite for auditing wireless networks. It includes tools for detecting networks, sniffing packets, cracking WEP and WPA/WPA2-PSK keys, and analyzing 802.11 wireless LANs. The suite works with wireless network cards that support monitor mode and can analyze 802.11a/b/g traffic. Main components The Aircrack-ng suite includes several specialized tools, each designed for specific wireless network assessment tasks: aircrack-ng : The core tool for cracking WEP and WPA/WPA2-PSK keys using various methods including FMS, PTW, KoreK, and dictionary attacks. airmon-ng : Enables and disables monitor mode on wireless interfaces, which is necessary for capturing raw 802.11 frames. airodump-ng : Captures raw 802.11 frames for analysis and key cracking. aireplay-ng : Injects and replays wireless frames to generate traffic for later analysis. Can perform deauthentication attacks to force clients to disconnect and capture handshakes. airbase-ng : Multi-purpose tool aimed at attacking clients rather than access points. Implements techniques like the Caffe Latte and Hirte attacks. airdecap-ng : Decrypts WEP/WPA/WPA2 capture files once keys are known. airtun-ng : Creates virtual tunnel interfaces. packetforge-ng : Creates various types of encrypted packets that can be used for injection. Additional tools The suite also includes several other specialized utilities: airdecloak-ng : Removes WEP Cloaking\u2122 from packet capture files. airdrop-ng : Rule-based wireless deauthentication tool. airgraph-ng : Graphs wireless networks to visualize relationships. airolib-ng : Precomputes WPA/WPA2 passphrases in a database for later use with aircrack-ng. airserv-ng : Wireless card TCP/IP server allowing multiple applications to use a wireless card. Command line examples Here are the most commonly used commands for the main tools in the Aircrack-ng suite: airmon-ng # Check for interfering processes airmon-ng check # Kill interfering processes airmon-ng check kill # Enable monitor mode on wireless interface airmon-ng start wlan0 # Enable monitor mode on a specific channel airmon-ng start wlan0 6 # Disable monitor mode airmon-ng stop wlan0mon airodump-ng # Capture all wireless traffic in range airodump-ng wlan0mon # Capture traffic from a specific access point airodump-ng --bssid 00:11:22:33:44:55 -c 6 wlan0mon # Save captured packets to a file airodump-ng --bssid 00:11:22:33:44:55 -c 6 -w capture wlan0mon # Capture only WPA handshakes airodump-ng --bssid 00:11:22:33:44:55 -c 6 -w capture --output-format pcap wlan0mon aireplay-ng # Test injection capabilities aireplay-ng -9 wlan0mon # Deauthenticate all clients from an access point aireplay-ng --deauth 0 -a 00:11:22:33:44:55 wlan0mon # Deauthenticate a specific client aireplay-ng --deauth 10 -a 00:11:22:33:44:55 -c AA:BB:CC:DD:EE:FF wlan0mon # Fake authentication with an access point aireplay-ng -1 0 -e \"NetworkName\" -a 00:11:22:33:44:55 -h 11:22:33:44:55:66 wlan0mon # ARP request replay attack (for WEP cracking) aireplay-ng -3 -b 00:11:22:33:44:55 -h 11:22:33:44:55:66 wlan0mon aircrack-ng # Crack WEP encryption aircrack-ng -b 00:11:22:33:44:55 capture*.cap # Crack WPA/WPA2 using a wordlist aircrack-ng -w wordlist.txt -b 00:11:22:33:44:55 capture*.cap # Crack with multiple CPU cores aircrack-ng -w wordlist.txt -b 00:11:22:33:44:55 capture*.cap -S # Show only the password if found aircrack-ng -w wordlist.txt -b 00:11:22:33:44:55 capture*.cap -l found_password.txt airdecap-ng # Decrypt WEP encrypted packets airdecap-ng -w 1A2B3C4D5E capture.cap # Decrypt WPA/WPA2 encrypted packets airdecap-ng -e \"NetworkName\" -p \"password\" capture.cap # Keep only decrypted packets airdecap-ng -w 1A2B3C4D5E -l capture.cap airolib-ng # Create a new database airolib-ng my_db --init # Import a wordlist into the database airolib-ng my_db --import passwd /path/to/wordlist.txt # Add an ESSID to the database airolib-ng my_db --import essid /path/to/essid.txt # Calculate PMKs (pre-computed keys) airolib-ng my_db --batch # Verify the database integrity airolib-ng my_db --verify all","title":"Aircrack-ng"},{"location":"tools/aircrack-ng.html#aircrack-ng","text":"Aircrack-ng is a network software suite for auditing wireless networks. It includes tools for detecting networks, sniffing packets, cracking WEP and WPA/WPA2-PSK keys, and analyzing 802.11 wireless LANs. The suite works with wireless network cards that support monitor mode and can analyze 802.11a/b/g traffic.","title":"Aircrack-ng"},{"location":"tools/aircrack-ng.html#main-components","text":"The Aircrack-ng suite includes several specialized tools, each designed for specific wireless network assessment tasks: aircrack-ng : The core tool for cracking WEP and WPA/WPA2-PSK keys using various methods including FMS, PTW, KoreK, and dictionary attacks. airmon-ng : Enables and disables monitor mode on wireless interfaces, which is necessary for capturing raw 802.11 frames. airodump-ng : Captures raw 802.11 frames for analysis and key cracking. aireplay-ng : Injects and replays wireless frames to generate traffic for later analysis. Can perform deauthentication attacks to force clients to disconnect and capture handshakes. airbase-ng : Multi-purpose tool aimed at attacking clients rather than access points. Implements techniques like the Caffe Latte and Hirte attacks. airdecap-ng : Decrypts WEP/WPA/WPA2 capture files once keys are known. airtun-ng : Creates virtual tunnel interfaces. packetforge-ng : Creates various types of encrypted packets that can be used for injection.","title":"Main components"},{"location":"tools/aircrack-ng.html#additional-tools","text":"The suite also includes several other specialized utilities: airdecloak-ng : Removes WEP Cloaking\u2122 from packet capture files. airdrop-ng : Rule-based wireless deauthentication tool. airgraph-ng : Graphs wireless networks to visualize relationships. airolib-ng : Precomputes WPA/WPA2 passphrases in a database for later use with aircrack-ng. airserv-ng : Wireless card TCP/IP server allowing multiple applications to use a wireless card.","title":"Additional tools"},{"location":"tools/aircrack-ng.html#command-line-examples","text":"Here are the most commonly used commands for the main tools in the Aircrack-ng suite:","title":"Command line examples"},{"location":"tools/aircrack-ng.html#airmon-ng","text":"# Check for interfering processes airmon-ng check # Kill interfering processes airmon-ng check kill # Enable monitor mode on wireless interface airmon-ng start wlan0 # Enable monitor mode on a specific channel airmon-ng start wlan0 6 # Disable monitor mode airmon-ng stop wlan0mon","title":"airmon-ng"},{"location":"tools/aircrack-ng.html#airodump-ng","text":"# Capture all wireless traffic in range airodump-ng wlan0mon # Capture traffic from a specific access point airodump-ng --bssid 00:11:22:33:44:55 -c 6 wlan0mon # Save captured packets to a file airodump-ng --bssid 00:11:22:33:44:55 -c 6 -w capture wlan0mon # Capture only WPA handshakes airodump-ng --bssid 00:11:22:33:44:55 -c 6 -w capture --output-format pcap wlan0mon","title":"airodump-ng"},{"location":"tools/aircrack-ng.html#aireplay-ng","text":"# Test injection capabilities aireplay-ng -9 wlan0mon # Deauthenticate all clients from an access point aireplay-ng --deauth 0 -a 00:11:22:33:44:55 wlan0mon # Deauthenticate a specific client aireplay-ng --deauth 10 -a 00:11:22:33:44:55 -c AA:BB:CC:DD:EE:FF wlan0mon # Fake authentication with an access point aireplay-ng -1 0 -e \"NetworkName\" -a 00:11:22:33:44:55 -h 11:22:33:44:55:66 wlan0mon # ARP request replay attack (for WEP cracking) aireplay-ng -3 -b 00:11:22:33:44:55 -h 11:22:33:44:55:66 wlan0mon","title":"aireplay-ng"},{"location":"tools/aircrack-ng.html#aircrack-ng_1","text":"# Crack WEP encryption aircrack-ng -b 00:11:22:33:44:55 capture*.cap # Crack WPA/WPA2 using a wordlist aircrack-ng -w wordlist.txt -b 00:11:22:33:44:55 capture*.cap # Crack with multiple CPU cores aircrack-ng -w wordlist.txt -b 00:11:22:33:44:55 capture*.cap -S # Show only the password if found aircrack-ng -w wordlist.txt -b 00:11:22:33:44:55 capture*.cap -l found_password.txt","title":"aircrack-ng"},{"location":"tools/aircrack-ng.html#airdecap-ng","text":"# Decrypt WEP encrypted packets airdecap-ng -w 1A2B3C4D5E capture.cap # Decrypt WPA/WPA2 encrypted packets airdecap-ng -e \"NetworkName\" -p \"password\" capture.cap # Keep only decrypted packets airdecap-ng -w 1A2B3C4D5E -l capture.cap","title":"airdecap-ng"},{"location":"tools/aircrack-ng.html#airolib-ng","text":"# Create a new database airolib-ng my_db --init # Import a wordlist into the database airolib-ng my_db --import passwd /path/to/wordlist.txt # Add an ESSID to the database airolib-ng my_db --import essid /path/to/essid.txt # Calculate PMKs (pre-computed keys) airolib-ng my_db --batch # Verify the database integrity airolib-ng my_db --verify all","title":"airolib-ng"},{"location":"tools/curl.html","text":"Curl curl is a versatile command-line tool that allows you to transfer data across networks using various protocols, such as HTTP, HTTPS, FTP, SFTP, and more. It\u2019s widely used by developers, sysadmins, and network engineers for tasks such as testing APIs, downloading files, and debugging network issues. Main usages Transfer Data Over the Network: curl can download or upload files, fetch web pages, and perform network-related operations. API Testing: You can use curl to interact with RESTful APIs by sending requests (GET, POST, PUT, DELETE, etc.) and receiving raw responses. Automating Requests: It\u2019s commonly used in scripts to automate repetitive tasks like monitoring web services or downloading files. Debugging Network Issues: curl provides detailed output about server responses (e.g., HTTP headers, status codes), helping to troubleshoot connectivity or server-side problems. Customizing HTTP Requests: You can send custom headers, manipulate cookies, include authentication, and much more. Command line examples This section will present some basic curl usages. Retrieve a webpage or download a file curl https://example.com This fetches the content of the webpage https://example.com and displays it in the terminal. To save it to a file: curl -o page.html https://example.com Get a webpage from a server using port 8000: curl also permits to specify the port used by the web server: curl http://www.example.com:8000/ Perform an HTTP GET request Fetch data from an API using a GET request: curl -X GET https://api.example.com/items Send two fields with two field names This permits to specify multipart data in the request body: curl -F \"docpicture=@dog.gif\" -F \"catpicture=@cat.gif\" https://api.example.com/ Perform an HTTP POST request with JSON Data This command will send data to an API: curl -X POST -H \"Content-Type: application/json\" -d '{\"name\":\"John\",\"age\":30}' https://api.example.com/users Download a file with authentication To download a file from a server that requires a username and password: curl -u username:password https://example.com/file.zip -O Or, if an API requires a Bearer Token for authentication: curl -H \"Authorization: Bearer YOUR_TOKEN\" https://api.example.com/data Display HTTP headers only To view only the HTTP response headers: curl -I https://example.com Upload a file via a POST request You can upload a file to a server: curl -X POST -F \"file=@myfile.txt\" https://example.com/upload Verbose Mode for Debugging Enable verbose output to see details about the request and response: curl -v https://example.com Useful options This section presents some useful curl options: -o <filename>: Save the output to a file with a custom name. -O: Save the output using the original filename from the server. -H <header>: Add a custom HTTP header. -X <method>: Specify the HTTP method (e.g., GET, POST). -d <data>: Send data in the request body (e.g., JSON for POST requests). -F: Send data as multipart/form-data (useful for file uploads). -u <user:pass>: Provide username and password for authentication. -k: Ignore SSL/TLS certificate errors. --limit-rate: Limit the transfer speed.","title":"Curl"},{"location":"tools/curl.html#curl","text":"curl is a versatile command-line tool that allows you to transfer data across networks using various protocols, such as HTTP, HTTPS, FTP, SFTP, and more. It\u2019s widely used by developers, sysadmins, and network engineers for tasks such as testing APIs, downloading files, and debugging network issues.","title":"Curl"},{"location":"tools/curl.html#main-usages","text":"Transfer Data Over the Network: curl can download or upload files, fetch web pages, and perform network-related operations. API Testing: You can use curl to interact with RESTful APIs by sending requests (GET, POST, PUT, DELETE, etc.) and receiving raw responses. Automating Requests: It\u2019s commonly used in scripts to automate repetitive tasks like monitoring web services or downloading files. Debugging Network Issues: curl provides detailed output about server responses (e.g., HTTP headers, status codes), helping to troubleshoot connectivity or server-side problems. Customizing HTTP Requests: You can send custom headers, manipulate cookies, include authentication, and much more.","title":"Main usages"},{"location":"tools/curl.html#command-line-examples","text":"This section will present some basic curl usages.","title":"Command line examples"},{"location":"tools/curl.html#retrieve-a-webpage-or-download-a-file","text":"curl https://example.com This fetches the content of the webpage https://example.com and displays it in the terminal. To save it to a file: curl -o page.html https://example.com","title":"Retrieve a webpage or download a file"},{"location":"tools/curl.html#get-a-webpage-from-a-server-using-port-8000","text":"curl also permits to specify the port used by the web server: curl http://www.example.com:8000/","title":"Get a webpage from a server using port 8000:"},{"location":"tools/curl.html#perform-an-http-get-request","text":"Fetch data from an API using a GET request: curl -X GET https://api.example.com/items","title":"Perform an HTTP GET request"},{"location":"tools/curl.html#send-two-fields-with-two-field-names","text":"This permits to specify multipart data in the request body: curl -F \"docpicture=@dog.gif\" -F \"catpicture=@cat.gif\" https://api.example.com/","title":"Send two fields with two field names"},{"location":"tools/curl.html#perform-an-http-post-request-with-json-data","text":"This command will send data to an API: curl -X POST -H \"Content-Type: application/json\" -d '{\"name\":\"John\",\"age\":30}' https://api.example.com/users","title":"Perform an HTTP POST request with JSON Data"},{"location":"tools/curl.html#download-a-file-with-authentication","text":"To download a file from a server that requires a username and password: curl -u username:password https://example.com/file.zip -O Or, if an API requires a Bearer Token for authentication: curl -H \"Authorization: Bearer YOUR_TOKEN\" https://api.example.com/data","title":"Download a file with authentication"},{"location":"tools/curl.html#display-http-headers-only","text":"To view only the HTTP response headers: curl -I https://example.com","title":"Display HTTP headers only"},{"location":"tools/curl.html#upload-a-file-via-a-post-request","text":"You can upload a file to a server: curl -X POST -F \"file=@myfile.txt\" https://example.com/upload","title":"Upload a file via a POST request"},{"location":"tools/curl.html#verbose-mode-for-debugging","text":"Enable verbose output to see details about the request and response: curl -v https://example.com","title":"Verbose Mode for Debugging"},{"location":"tools/curl.html#useful-options","text":"This section presents some useful curl options: -o <filename>: Save the output to a file with a custom name. -O: Save the output using the original filename from the server. -H <header>: Add a custom HTTP header. -X <method>: Specify the HTTP method (e.g., GET, POST). -d <data>: Send data in the request body (e.g., JSON for POST requests). -F: Send data as multipart/form-data (useful for file uploads). -u <user:pass>: Provide username and password for authentication. -k: Ignore SSL/TLS certificate errors. --limit-rate: Limit the transfer speed.","title":"Useful options"},{"location":"tools/docker.html","text":"Docker Docker is an open-source platform that enables developers to build, package, and deploy applications in lightweight, portable containers. These containers allow applications to run consistently across different environments, whether it's a developer\u2019s laptop, a testing server, or a production cloud server. Docker simplifies software deployment by bundling an application with all its dependencies, libraries, and configurations into a single container image that can run anywhere. Main usages Microservices: Run independent services in separate containers. CI/CD Pipelines: Automate application testing and deployment. Cloud Deployments: Deploy scalable applications with Kubernetes. Local Development: Develop in isolated environments without affecting the host system. The containers have a good portability between systems, and permi to easily deploy multiple instances of an application. They are more efficient a rapid to deploy than classic virtual machines. Additionally, they allow to a good isolation with each container that runs in its own environment without interfering with other applications. How Docker works Docker operates using three main components: Docker Image: A template containing an application and its dependencies. Example: python:3.9 , nginx:latest Docker Container: A running instance of an image. Example: running an Nginx web server inside a container. Docker Engine: The core runtime that manages images, containers, and networks. Here are the main differences, at a high level, between a container and a virtual machine: Features Container Virtual Machine Size Lightweight (MBs) Heavy (GBs) Startup Time Seconds Minutes Performance Near native Slower Isolation Process level Full OS level Use Case Microservices, DevOps Full OS virtualization Command line examples This section will present some basic commands to work with Docker. Install Docker To install Docker, here are the steps depending on your operating system. Linux: sudo apt install docker.io macOS/Windows: Download from Docker\u2019s official website. Check Docker version docker --version Run a container In this example, it is a Nginx web server. docker run -d -p 80:80 --name my-nginx nginx This command pulls the latest Nginx image, starts a container in detached mode (-d), and maps port 80 of the container to port 80 of the host. List running containers docker ps Stop and remove a container docker stop my-nginx docker rm my-nginx Pull a specific image This command will pull a Docker image from the official Docker registry (here, the latest Ubuntu image). docker pull ubuntu:latest To pull a custom image from a specific registry: docker image pull myregistry.local:5000/testing/test-image Run an interactive container This command permits to open an interactive shell inside an Ubuntu container. docker run -it ubuntu bash Build a custom image By using a Dockerfile , it is possible to create and build a custom Docker image. A Dockerfile is a simple text file, named Dockerfile , that contains all the instructions for Docker to create the image. Create a Dockerfile for a Python application: FROM python:3.9 WORKDIR /app COPY . /app CMD [\"python\", \"app.py\"] Then build and run: docker build -t my-python-app . docker run my-python-app Remove unused images docker system prune -a","title":"Docker"},{"location":"tools/docker.html#docker","text":"Docker is an open-source platform that enables developers to build, package, and deploy applications in lightweight, portable containers. These containers allow applications to run consistently across different environments, whether it's a developer\u2019s laptop, a testing server, or a production cloud server. Docker simplifies software deployment by bundling an application with all its dependencies, libraries, and configurations into a single container image that can run anywhere.","title":"Docker"},{"location":"tools/docker.html#main-usages","text":"Microservices: Run independent services in separate containers. CI/CD Pipelines: Automate application testing and deployment. Cloud Deployments: Deploy scalable applications with Kubernetes. Local Development: Develop in isolated environments without affecting the host system. The containers have a good portability between systems, and permi to easily deploy multiple instances of an application. They are more efficient a rapid to deploy than classic virtual machines. Additionally, they allow to a good isolation with each container that runs in its own environment without interfering with other applications.","title":"Main usages"},{"location":"tools/docker.html#how-docker-works","text":"Docker operates using three main components: Docker Image: A template containing an application and its dependencies. Example: python:3.9 , nginx:latest Docker Container: A running instance of an image. Example: running an Nginx web server inside a container. Docker Engine: The core runtime that manages images, containers, and networks. Here are the main differences, at a high level, between a container and a virtual machine: Features Container Virtual Machine Size Lightweight (MBs) Heavy (GBs) Startup Time Seconds Minutes Performance Near native Slower Isolation Process level Full OS level Use Case Microservices, DevOps Full OS virtualization","title":"How Docker works"},{"location":"tools/docker.html#command-line-examples","text":"This section will present some basic commands to work with Docker.","title":"Command line examples"},{"location":"tools/docker.html#install-docker","text":"To install Docker, here are the steps depending on your operating system. Linux: sudo apt install docker.io macOS/Windows: Download from Docker\u2019s official website.","title":"Install Docker"},{"location":"tools/docker.html#check-docker-version","text":"docker --version","title":"Check Docker version"},{"location":"tools/docker.html#run-a-container","text":"In this example, it is a Nginx web server. docker run -d -p 80:80 --name my-nginx nginx This command pulls the latest Nginx image, starts a container in detached mode (-d), and maps port 80 of the container to port 80 of the host.","title":"Run a container"},{"location":"tools/docker.html#list-running-containers","text":"docker ps","title":"List running containers"},{"location":"tools/docker.html#stop-and-remove-a-container","text":"docker stop my-nginx docker rm my-nginx","title":"Stop and remove a container"},{"location":"tools/docker.html#pull-a-specific-image","text":"This command will pull a Docker image from the official Docker registry (here, the latest Ubuntu image). docker pull ubuntu:latest To pull a custom image from a specific registry: docker image pull myregistry.local:5000/testing/test-image","title":"Pull a specific image"},{"location":"tools/docker.html#run-an-interactive-container","text":"This command permits to open an interactive shell inside an Ubuntu container. docker run -it ubuntu bash","title":"Run an interactive container"},{"location":"tools/docker.html#build-a-custom-image","text":"By using a Dockerfile , it is possible to create and build a custom Docker image. A Dockerfile is a simple text file, named Dockerfile , that contains all the instructions for Docker to create the image. Create a Dockerfile for a Python application: FROM python:3.9 WORKDIR /app COPY . /app CMD [\"python\", \"app.py\"] Then build and run: docker build -t my-python-app . docker run my-python-app","title":"Build a custom image"},{"location":"tools/docker.html#remove-unused-images","text":"docker system prune -a","title":"Remove unused images"},{"location":"tools/jwt_tool.html","text":"Jwt_tool jwt_tool is a suite of open-source tools (Python 3) designed to audit, manipulate and break JSON Web Tokens (JWTs). It enables pentesters and security engineers to : decode and analyse a JWT test for known vulnerabilities (alg=none, alg confusion, etc.), forge and manipulate tokens dynamically, carry out dictionary attacks to break the secret key. Main usages Decoding / inspection: display JWT header and claims, including expiry date, signature, etc. Security / vulnerability analysis : none algorithm detection, HMAC-RS/HS attack (public key used as secret), exploits on corrupted claims. Forging / tampering: modifying the JWT header and payload (claims, algorithms, kid, etc.) to test the robustness of the target service. Key brute-force: offline dictionary or brute-force attack (several thousand words/sec). Automatic sending of requests: scan an HTTP endpoint by injecting your token, via header or cookie. Installation Installation is just a case of cloning the GitHub repository. git clone https://github.com/ticarpi/jwt_tool python3 -m pip install -r requirements.txt On first run the tool will generate a config file, some utility files, logfile, and a set of Public and Private keys in various formats. Command line examples This section will present some basic jwt_tool usages. Decode a JWT This displays header, payload, time fields (exp, iat...) and validates the signature if possible. python3 jwt_tool.py <JWT> Check a public key Allows to validate that a public key is the good one to verify the JWT with a RSA algorithm. python3 jwt_tool.py <JWT> -V -pk public.pem Tampering Allows you to inject/modify header/payload fields via an interactive menu. Displays header, payload, time fields (exp, iat...) and validates the signature if possible. python3 jwt_tool.py <JWT> -T -S <algorithm> -p <password> Known exploits jwt_tool allows to perform several known attacks on JWT, like the none and null algorithms, or the key confusion between RS256 and HS256. # None algorithm injection python3 jwt_tool.py <JWT> -X a # Key confusion attack python3 jwt_tool.py <JWT> -X k -pk public_key.pub Dictionnary bruteforce attack Since jwt_tools is developped in Python, this is not the most efficient way to perform a brute-force attack. In the real world, you would use a more efficient tool like hashcat or john the ripper to perform this kind of attack. However, jwt_tool is able to perform this attack. python3 jwt_tool.py -C -d wordlist.txt <JWT> Automatic tests jwt_tool permits to perform automatic attacks against a server by injecting multiple headers in the HTTP requests and the JWT to attemps to tamper with the JWT, and prompt the server to validate a modified JWT. Use the at argument to perform all the attacks. python3 jwt_tool.py -M at -t \"https://api.example.com/endpoint\" -rh \"Authorization: Bearer <JWT>\" Vulnerabilities covered The following CVEs exist for JWT libraries: CVE-2015-9235 alg:none Attack CVE-2016-5431 Key Confusion Attack CVE-2018-0114 Key Injection Attack CVE-2020-28042 Null Signature Attack Additional known attacks JWKS Spoofing \"kid\" Injection Cross-service relay attacks Weak secret used as a key Useful options This section presents some useful jwt_tool options: -b, --bare return TOKENS ONLY -t TARGETURL, --targeturl TARGETURL URL to send HTTP request to with new JWT -r REQUEST, --request REQUEST URL request to base on -rt RATE, --rate RATE Max. number of requests per minute -i, --insecure Use HTTP for passed request -rc COOKIES, --cookies COOKIES request cookies to send with the forged HTTP request -rh HEADERS, --headers HEADERS request headers to send with the forged HTTP request (can be used multiple times for additional headers) -pd POSTDATA, --postdata POSTDATA text string that contains all the data to be sent in a POST request -cv CANARYVALUE, --canaryvalue CANARYVALUE text string that appears in response for valid token (e.g. \"Welcome, ticarpi\") -np, --noproxy disable proxy for current request (change in jwtconf.ini if permanent) -nr, --noredir disable redirects for current request (change in jwtconf.ini if permanent) -M MODE, --mode MODE Scanning mode: pb = playbook audit er = fuzz existing claims to force errors cc = fuzz common claims at - All Tests! -X EXPLOIT, --exploit EXPLOIT eXploit known vulnerabilities: a = alg:none n = null signature b = blank password accepted in signature p = 'psychic signature' accepted in ECDSA signing s = spoof JWKS (specify JWKS URL with -ju, or set in jwtconf.ini to automate this attack) k = key confusion (specify public key with -pk) i = inject inline JWKS -ju JWKSURL, --jwksurl JWKSURL URL location where you can host a spoofed JWKS -S SIGN, --sign SIGN sign the resulting token: hs256/hs384/hs512 = HMAC-SHA signing (specify a secret with -k/-p) rs256/rs384/rs512 = RSA signing (specify an RSA private key with -pr) es256/es384/es512 = Elliptic Curve signing (specify an EC private key with -pr) ps256/ps384/ps512 = PSS-RSA signing (specify an RSA private key with -pr) -pr PRIVKEY, --privkey PRIVKEY Private Key for Asymmetric crypto -T, --tamper tamper with the JWT contents (set signing options with -S or use exploits with -X) -I, --injectclaims inject new claims and update existing claims with new values (set signing options with -S or use exploits with -X) (set target claim with -hc/-pc and injection values/lists with -hv/-pv -hc HEADERCLAIM, --headerclaim HEADERCLAIM Header claim to tamper with -pc PAYLOADCLAIM, --payloadclaim PAYLOADCLAIM Payload claim to tamper with -hv HEADERVALUE, --headervalue HEADERVALUE Value (or file containing values) to inject into tampered header claim -pv PAYLOADVALUE, --payloadvalue PAYLOADVALUE Value (or file containing values) to inject into tampered payload claim -C, --crack crack key for an HMAC-SHA token (specify -d/-p/-kf) -d DICT, --dict DICT dictionary file for cracking -p PASSWORD, --password PASSWORD password for cracking -kf KEYFILE, --keyfile KEYFILE keyfile for cracking (when signed with 'kid' attacks) -V, --verify verify the RSA signature against a Public Key (specify -pk/-jw) -pk PUBKEY, --pubkey PUBKEY Public Key for Asymmetric crypto -jw JWKSFILE, --jwksfile JWKSFILE JSON Web Key Store for Asymmetric crypto -Q QUERY, --query QUERY Query a token ID against the logfile to see the details of that request e.g. -Q jwttool_46820e62fe25c10a3f5498e426a9f03a -v, --verbose When parsing and printing, produce (slightly more) verbose output.","title":"Jwt_tool"},{"location":"tools/jwt_tool.html#jwt_tool","text":"jwt_tool is a suite of open-source tools (Python 3) designed to audit, manipulate and break JSON Web Tokens (JWTs). It enables pentesters and security engineers to : decode and analyse a JWT test for known vulnerabilities (alg=none, alg confusion, etc.), forge and manipulate tokens dynamically, carry out dictionary attacks to break the secret key.","title":"Jwt_tool"},{"location":"tools/jwt_tool.html#main-usages","text":"Decoding / inspection: display JWT header and claims, including expiry date, signature, etc. Security / vulnerability analysis : none algorithm detection, HMAC-RS/HS attack (public key used as secret), exploits on corrupted claims. Forging / tampering: modifying the JWT header and payload (claims, algorithms, kid, etc.) to test the robustness of the target service. Key brute-force: offline dictionary or brute-force attack (several thousand words/sec). Automatic sending of requests: scan an HTTP endpoint by injecting your token, via header or cookie.","title":"Main usages"},{"location":"tools/jwt_tool.html#installation","text":"Installation is just a case of cloning the GitHub repository. git clone https://github.com/ticarpi/jwt_tool python3 -m pip install -r requirements.txt On first run the tool will generate a config file, some utility files, logfile, and a set of Public and Private keys in various formats.","title":"Installation"},{"location":"tools/jwt_tool.html#command-line-examples","text":"This section will present some basic jwt_tool usages.","title":"Command line examples"},{"location":"tools/jwt_tool.html#decode-a-jwt","text":"This displays header, payload, time fields (exp, iat...) and validates the signature if possible. python3 jwt_tool.py <JWT>","title":"Decode a JWT"},{"location":"tools/jwt_tool.html#check-a-public-key","text":"Allows to validate that a public key is the good one to verify the JWT with a RSA algorithm. python3 jwt_tool.py <JWT> -V -pk public.pem","title":"Check a public key"},{"location":"tools/jwt_tool.html#tampering","text":"Allows you to inject/modify header/payload fields via an interactive menu. Displays header, payload, time fields (exp, iat...) and validates the signature if possible. python3 jwt_tool.py <JWT> -T -S <algorithm> -p <password>","title":"Tampering"},{"location":"tools/jwt_tool.html#known-exploits","text":"jwt_tool allows to perform several known attacks on JWT, like the none and null algorithms, or the key confusion between RS256 and HS256. # None algorithm injection python3 jwt_tool.py <JWT> -X a # Key confusion attack python3 jwt_tool.py <JWT> -X k -pk public_key.pub","title":"Known exploits"},{"location":"tools/jwt_tool.html#dictionnary-bruteforce-attack","text":"Since jwt_tools is developped in Python, this is not the most efficient way to perform a brute-force attack. In the real world, you would use a more efficient tool like hashcat or john the ripper to perform this kind of attack. However, jwt_tool is able to perform this attack. python3 jwt_tool.py -C -d wordlist.txt <JWT>","title":"Dictionnary bruteforce attack"},{"location":"tools/jwt_tool.html#automatic-tests","text":"jwt_tool permits to perform automatic attacks against a server by injecting multiple headers in the HTTP requests and the JWT to attemps to tamper with the JWT, and prompt the server to validate a modified JWT. Use the at argument to perform all the attacks. python3 jwt_tool.py -M at -t \"https://api.example.com/endpoint\" -rh \"Authorization: Bearer <JWT>\"","title":"Automatic tests"},{"location":"tools/jwt_tool.html#vulnerabilities-covered","text":"The following CVEs exist for JWT libraries: CVE-2015-9235 alg:none Attack CVE-2016-5431 Key Confusion Attack CVE-2018-0114 Key Injection Attack CVE-2020-28042 Null Signature Attack Additional known attacks JWKS Spoofing \"kid\" Injection Cross-service relay attacks Weak secret used as a key","title":"Vulnerabilities covered"},{"location":"tools/jwt_tool.html#useful-options","text":"This section presents some useful jwt_tool options: -b, --bare return TOKENS ONLY -t TARGETURL, --targeturl TARGETURL URL to send HTTP request to with new JWT -r REQUEST, --request REQUEST URL request to base on -rt RATE, --rate RATE Max. number of requests per minute -i, --insecure Use HTTP for passed request -rc COOKIES, --cookies COOKIES request cookies to send with the forged HTTP request -rh HEADERS, --headers HEADERS request headers to send with the forged HTTP request (can be used multiple times for additional headers) -pd POSTDATA, --postdata POSTDATA text string that contains all the data to be sent in a POST request -cv CANARYVALUE, --canaryvalue CANARYVALUE text string that appears in response for valid token (e.g. \"Welcome, ticarpi\") -np, --noproxy disable proxy for current request (change in jwtconf.ini if permanent) -nr, --noredir disable redirects for current request (change in jwtconf.ini if permanent) -M MODE, --mode MODE Scanning mode: pb = playbook audit er = fuzz existing claims to force errors cc = fuzz common claims at - All Tests! -X EXPLOIT, --exploit EXPLOIT eXploit known vulnerabilities: a = alg:none n = null signature b = blank password accepted in signature p = 'psychic signature' accepted in ECDSA signing s = spoof JWKS (specify JWKS URL with -ju, or set in jwtconf.ini to automate this attack) k = key confusion (specify public key with -pk) i = inject inline JWKS -ju JWKSURL, --jwksurl JWKSURL URL location where you can host a spoofed JWKS -S SIGN, --sign SIGN sign the resulting token: hs256/hs384/hs512 = HMAC-SHA signing (specify a secret with -k/-p) rs256/rs384/rs512 = RSA signing (specify an RSA private key with -pr) es256/es384/es512 = Elliptic Curve signing (specify an EC private key with -pr) ps256/ps384/ps512 = PSS-RSA signing (specify an RSA private key with -pr) -pr PRIVKEY, --privkey PRIVKEY Private Key for Asymmetric crypto -T, --tamper tamper with the JWT contents (set signing options with -S or use exploits with -X) -I, --injectclaims inject new claims and update existing claims with new values (set signing options with -S or use exploits with -X) (set target claim with -hc/-pc and injection values/lists with -hv/-pv -hc HEADERCLAIM, --headerclaim HEADERCLAIM Header claim to tamper with -pc PAYLOADCLAIM, --payloadclaim PAYLOADCLAIM Payload claim to tamper with -hv HEADERVALUE, --headervalue HEADERVALUE Value (or file containing values) to inject into tampered header claim -pv PAYLOADVALUE, --payloadvalue PAYLOADVALUE Value (or file containing values) to inject into tampered payload claim -C, --crack crack key for an HMAC-SHA token (specify -d/-p/-kf) -d DICT, --dict DICT dictionary file for cracking -p PASSWORD, --password PASSWORD password for cracking -kf KEYFILE, --keyfile KEYFILE keyfile for cracking (when signed with 'kid' attacks) -V, --verify verify the RSA signature against a Public Key (specify -pk/-jw) -pk PUBKEY, --pubkey PUBKEY Public Key for Asymmetric crypto -jw JWKSFILE, --jwksfile JWKSFILE JSON Web Key Store for Asymmetric crypto -Q QUERY, --query QUERY Query a token ID against the logfile to see the details of that request e.g. -Q jwttool_46820e62fe25c10a3f5498e426a9f03a -v, --verbose When parsing and printing, produce (slightly more) verbose output.","title":"Useful options"},{"location":"tools/nmap.html","text":"Nmap nmap is a powerful and versatile tool widely used in network security and administration. nmap (short for Network Mapper) is an open-source tool designed for network exploration, security auditing, and vulnerability scanning. It is primarily used to discover hosts and services on a network, assess their security posture, and gather information about them. nmap is widely used by network administrators, security professionals, and ethical hackers to map networks, identify vulnerabilities, and monitor open ports and running services. Its functionality can be extended with additional scripts and tools. Main usages Network Discovery: It can identify active hosts on a network, helping to map out the devices connected to an infrastructure. Port Scanning: nmap scans for open ports on devices, revealing which services (e.g., HTTP, FTP, SSH) are running and accessible. Service and Version Detection: nmap can detect the services running on open ports and determine their software versions. Operating System Detection: By analyzing network responses, nmap can guess the operating system of the target device. Vulnerability Assessment: With its scripting engine (NSE - Nmap Scripting Engine), nmap can check for known vulnerabilities and misconfigurations in network services. Firewall Evasion and Stealth Scanning: It provides options to bypass firewalls, IDS/IPS systems, or scan in a less detectable manner. Performance and Scalability: nmap works well on networks of all sizes, from small LANs to large, distributed networks. Command line examples This section will present some basic nmap usages. Basic ping scan nam can find devices that are active on the network: nmap -sn 192.168.1.0/24 This scans the subnet 192.168.1.0/24 to list all active devices (ping only). Scan for open ports Check which ports are open on a specific host: nmap 192.168.1.10 By default, this scans the 1,000 most common TCP ports. Detect service versions Identify the services and their versions running on open ports: nmap -sV 192.168.1.10 Perform an OS detection scan nmap is also able to guess the operating system running on a target: nmap -O 192.168.1.10 Scan a range of IPs It is also possible to scan multiple hosts by specifying a range of IP addresses: nmap 192.168.1.1-100 192.168.2.0/24 Multiple targets and ranges can be added into a single command. Scan specific ports To scan specific ports (e.g., 22 and 80): nmap -p 22,80 192.168.1.10 To perform a full scan on the 65535 TCP ports, the -p- parameter can be used. UDP scan By default, nmap only scan the TCP ports. -sU must be indicated to scan the UDP ports: nmap -sU 192.168.1.1 Run vulnerability scans with NSE Using Nmap's scripting engine, it can run security scripts. For example: nmap --script vuln 192.168.1.10 This uses vulnerability detection scripts from the NSE. Stealth scan To avoid triggering alarms on firewalls or IDS, you can use a SYN scan: nmap -sS 192.168.1.10 This will only perform the SYN request of the TCP exchange, and nmap will not perform the full exchange. However, this method is now more detected as it was in the past. Save scan results It is also possible to save the scan results to a file for later analysis: nmap -oN scan_results.txt 192.168.1.10 Useful options This section presents some useful nmap options: -sn Ping scan (no port scanning). -sS SYN scan (stealth scan). -sU UDP scan. -sV Detect service versions. -O Detect the operating system. -p Specify ports to scan. --script Run Nmap Scripting Engine (NSE) scripts. -sC Run the default NSE scripts, equivalent to --script=safe,intrusive. -oN Save results in a human-readable format. -oX Save results in XML format. -T Adjust the speed of the scan (0-5).","title":"Nmap"},{"location":"tools/nmap.html#nmap","text":"nmap is a powerful and versatile tool widely used in network security and administration. nmap (short for Network Mapper) is an open-source tool designed for network exploration, security auditing, and vulnerability scanning. It is primarily used to discover hosts and services on a network, assess their security posture, and gather information about them. nmap is widely used by network administrators, security professionals, and ethical hackers to map networks, identify vulnerabilities, and monitor open ports and running services. Its functionality can be extended with additional scripts and tools.","title":"Nmap"},{"location":"tools/nmap.html#main-usages","text":"Network Discovery: It can identify active hosts on a network, helping to map out the devices connected to an infrastructure. Port Scanning: nmap scans for open ports on devices, revealing which services (e.g., HTTP, FTP, SSH) are running and accessible. Service and Version Detection: nmap can detect the services running on open ports and determine their software versions. Operating System Detection: By analyzing network responses, nmap can guess the operating system of the target device. Vulnerability Assessment: With its scripting engine (NSE - Nmap Scripting Engine), nmap can check for known vulnerabilities and misconfigurations in network services. Firewall Evasion and Stealth Scanning: It provides options to bypass firewalls, IDS/IPS systems, or scan in a less detectable manner. Performance and Scalability: nmap works well on networks of all sizes, from small LANs to large, distributed networks.","title":"Main usages"},{"location":"tools/nmap.html#command-line-examples","text":"This section will present some basic nmap usages.","title":"Command line examples"},{"location":"tools/nmap.html#basic-ping-scan","text":"nam can find devices that are active on the network: nmap -sn 192.168.1.0/24 This scans the subnet 192.168.1.0/24 to list all active devices (ping only).","title":"Basic ping scan"},{"location":"tools/nmap.html#scan-for-open-ports","text":"Check which ports are open on a specific host: nmap 192.168.1.10 By default, this scans the 1,000 most common TCP ports.","title":"Scan for open ports"},{"location":"tools/nmap.html#detect-service-versions","text":"Identify the services and their versions running on open ports: nmap -sV 192.168.1.10","title":"Detect service versions"},{"location":"tools/nmap.html#perform-an-os-detection-scan","text":"nmap is also able to guess the operating system running on a target: nmap -O 192.168.1.10","title":"Perform an OS detection scan"},{"location":"tools/nmap.html#scan-a-range-of-ips","text":"It is also possible to scan multiple hosts by specifying a range of IP addresses: nmap 192.168.1.1-100 192.168.2.0/24 Multiple targets and ranges can be added into a single command.","title":"Scan a range of IPs"},{"location":"tools/nmap.html#scan-specific-ports","text":"To scan specific ports (e.g., 22 and 80): nmap -p 22,80 192.168.1.10 To perform a full scan on the 65535 TCP ports, the -p- parameter can be used.","title":"Scan specific ports"},{"location":"tools/nmap.html#udp-scan","text":"By default, nmap only scan the TCP ports. -sU must be indicated to scan the UDP ports: nmap -sU 192.168.1.1","title":"UDP scan"},{"location":"tools/nmap.html#run-vulnerability-scans-with-nse","text":"Using Nmap's scripting engine, it can run security scripts. For example: nmap --script vuln 192.168.1.10 This uses vulnerability detection scripts from the NSE.","title":"Run vulnerability scans with NSE"},{"location":"tools/nmap.html#stealth-scan","text":"To avoid triggering alarms on firewalls or IDS, you can use a SYN scan: nmap -sS 192.168.1.10 This will only perform the SYN request of the TCP exchange, and nmap will not perform the full exchange. However, this method is now more detected as it was in the past.","title":"Stealth scan"},{"location":"tools/nmap.html#save-scan-results","text":"It is also possible to save the scan results to a file for later analysis: nmap -oN scan_results.txt 192.168.1.10","title":"Save scan results"},{"location":"tools/nmap.html#useful-options","text":"This section presents some useful nmap options: -sn Ping scan (no port scanning). -sS SYN scan (stealth scan). -sU UDP scan. -sV Detect service versions. -O Detect the operating system. -p Specify ports to scan. --script Run Nmap Scripting Engine (NSE) scripts. -sC Run the default NSE scripts, equivalent to --script=safe,intrusive. -oN Save results in a human-readable format. -oX Save results in XML format. -T Adjust the speed of the scan (0-5).","title":"Useful options"},{"location":"tools/nmcli.html","text":"Nmcli nmcli is a powerful command-line tool for controlling NetworkManager and reporting network status. It can be used as a replacement for graphical network management tools, especially on servers, headless machines, and terminals where no GUI is available. Main usages Network Connection Management : Create, display, edit, delete, activate, and deactivate network connections. Device Control : Monitor and control network device status. Script Automation : Utilize NetworkManager via nmcli instead of managing network connections manually. Server Administration : Control NetworkManager without a GUI, including creating, editing, starting and stopping network connections. Network Status Monitoring : View detailed information about network connections and devices. Command line examples This section presents some basic nmcli usages. Check NetworkManager status nmcli general status This displays the overall status of NetworkManager, including connectivity state and hardware status. View network connections nmcli connection show Lists all network connections that NetworkManager has configured. View only active connections nmcli connection show --active Shows only the currently active network connections. View network devices status nmcli device status Displays all network devices recognized by NetworkManager and their current state. Turn Wi-Fi on or off nmcli radio wifi on Or to turn it off: nmcli radio wifi off Connect to a Wi-Fi network nmcli dev wifi connect \"SSID_Name\" password \"wifi_password\" name \"Connection_Name\" Creates a new connection profile and connects to the specified Wi-Fi network. Activate an existing connection nmcli con up id \"Connection_Name\" Or using the connection's UUID: nmcli con up uuid 6b028a27-6dc9-4411-9886-e9ad1dd43761 Disconnect a device nmcli dev disconnect iface eth0 Disconnects the connection on the specified interface and marks the device as unavailable for auto-connecting. View available Wi-Fi networks nmcli dev wifi Lists all available Wi-Fi access points known by the NetworkManager. View detailed information about a specific connection nmcli con show id \"Connection_Name\" Displays all details of the connection with the specified name. Useful options This section presents some useful nmcli options: -t, --terse: Output in terse mode (better for script processing) -p, --pretty: Output in pretty mode (human-readable, aligned values) -f, --fields: Specify which fields to display (e.g., NAME,UUID,TYPE) -h, --help: Display help information","title":"Nmcli"},{"location":"tools/nmcli.html#nmcli","text":"nmcli is a powerful command-line tool for controlling NetworkManager and reporting network status. It can be used as a replacement for graphical network management tools, especially on servers, headless machines, and terminals where no GUI is available.","title":"Nmcli"},{"location":"tools/nmcli.html#main-usages","text":"Network Connection Management : Create, display, edit, delete, activate, and deactivate network connections. Device Control : Monitor and control network device status. Script Automation : Utilize NetworkManager via nmcli instead of managing network connections manually. Server Administration : Control NetworkManager without a GUI, including creating, editing, starting and stopping network connections. Network Status Monitoring : View detailed information about network connections and devices.","title":"Main usages"},{"location":"tools/nmcli.html#command-line-examples","text":"This section presents some basic nmcli usages.","title":"Command line examples"},{"location":"tools/nmcli.html#check-networkmanager-status","text":"nmcli general status This displays the overall status of NetworkManager, including connectivity state and hardware status.","title":"Check NetworkManager status"},{"location":"tools/nmcli.html#view-network-connections","text":"nmcli connection show Lists all network connections that NetworkManager has configured.","title":"View network connections"},{"location":"tools/nmcli.html#view-only-active-connections","text":"nmcli connection show --active Shows only the currently active network connections.","title":"View only active connections"},{"location":"tools/nmcli.html#view-network-devices-status","text":"nmcli device status Displays all network devices recognized by NetworkManager and their current state.","title":"View network devices status"},{"location":"tools/nmcli.html#turn-wi-fi-on-or-off","text":"nmcli radio wifi on Or to turn it off: nmcli radio wifi off","title":"Turn Wi-Fi on or off"},{"location":"tools/nmcli.html#connect-to-a-wi-fi-network","text":"nmcli dev wifi connect \"SSID_Name\" password \"wifi_password\" name \"Connection_Name\" Creates a new connection profile and connects to the specified Wi-Fi network.","title":"Connect to a Wi-Fi network"},{"location":"tools/nmcli.html#activate-an-existing-connection","text":"nmcli con up id \"Connection_Name\" Or using the connection's UUID: nmcli con up uuid 6b028a27-6dc9-4411-9886-e9ad1dd43761","title":"Activate an existing connection"},{"location":"tools/nmcli.html#disconnect-a-device","text":"nmcli dev disconnect iface eth0 Disconnects the connection on the specified interface and marks the device as unavailable for auto-connecting.","title":"Disconnect a device"},{"location":"tools/nmcli.html#view-available-wi-fi-networks","text":"nmcli dev wifi Lists all available Wi-Fi access points known by the NetworkManager.","title":"View available Wi-Fi networks"},{"location":"tools/nmcli.html#view-detailed-information-about-a-specific-connection","text":"nmcli con show id \"Connection_Name\" Displays all details of the connection with the specified name.","title":"View detailed information about a specific connection"},{"location":"tools/nmcli.html#useful-options","text":"This section presents some useful nmcli options: -t, --terse: Output in terse mode (better for script processing) -p, --pretty: Output in pretty mode (human-readable, aligned values) -f, --fields: Specify which fields to display (e.g., NAME,UUID,TYPE) -h, --help: Display help information","title":"Useful options"},{"location":"tools/wireshark.html","text":"Wireshark Wireshark is a powerful, open-source network protocol analyzer used for network troubleshooting, analysis, and software and communications protocol development. It allows you to capture and interactively browse the traffic running on a computer network. Main usages Network Troubleshooting: Diagnose network issues and performance problems. Security Analysis: Detect network intrusions and analyze suspicious traffic. Protocol Analysis: Study and understand network protocols in detail. Application Debugging: Debug network-related issues in applications. Educational Tool: Learn about network protocols and communication. How Wireshark works Wireshark captures packets from a network interface and analyzes them. It uses a library called libpcap (on Unix-like systems) or WinPcap/Npcap (on Windows) to capture packets. The main components of Wireshark are: Capture Engine: Captures live network traffic. Dissectors: Interpret and analyze various network protocols. User Interface: Displays captured data in a human-readable format. Key features Live capture and offline analysis Deep inspection of hundreds of protocols Multi-platform: Runs on Windows, Linux, macOS, and other Unix-like systems Powerful display filters Rich VoIP analysis Decryption support for many protocols Command line examples While Wireshark is primarily a GUI application, it also offers command-line tools like tshark for terminal-based analysis. Start Wireshark from command line wireshark Capture packets on a specific interface wireshark -i eth0 -k This command starts Wireshark, captures on the eth0 interface (-i eth0), and immediately starts capturing (-k). Capture with a filter wireshark -i eth0 -f \"port 80\" This captures only HTTP traffic on eth0. Read from a capture file wireshark -r capture.pcap This opens a previously saved capture file. Using display filters Display filters in Wireshark allow you to focus on specific types of traffic. Here are some common filters: Filter Purpose Syntax Show only HTTP traffic http Show traffic to/from a specific IP ip.addr == 192.168.1.1 Show TCP traffic on port 80 tcp.port == 80 Show all traffic except ARP and DNS !(arp or dns) Analyzing packets To analyze packets in Wireshark: Start a capture or open a capture file. Apply relevant display filters. Click on a packet in the packet list pane to view its details. Expand the protocol layers in the packet details pane to examine specific fields. Tips for effective use Use coloring rules to highlight important packets. Save frequently used filters as filter buttons. Use the \"Follow TCP Stream\" feature to reconstruct conversations. Leverage Wireshark's statistical tools for traffic analysis.","title":"Wireshark"},{"location":"tools/wireshark.html#wireshark","text":"Wireshark is a powerful, open-source network protocol analyzer used for network troubleshooting, analysis, and software and communications protocol development. It allows you to capture and interactively browse the traffic running on a computer network.","title":"Wireshark"},{"location":"tools/wireshark.html#main-usages","text":"Network Troubleshooting: Diagnose network issues and performance problems. Security Analysis: Detect network intrusions and analyze suspicious traffic. Protocol Analysis: Study and understand network protocols in detail. Application Debugging: Debug network-related issues in applications. Educational Tool: Learn about network protocols and communication.","title":"Main usages"},{"location":"tools/wireshark.html#how-wireshark-works","text":"Wireshark captures packets from a network interface and analyzes them. It uses a library called libpcap (on Unix-like systems) or WinPcap/Npcap (on Windows) to capture packets. The main components of Wireshark are: Capture Engine: Captures live network traffic. Dissectors: Interpret and analyze various network protocols. User Interface: Displays captured data in a human-readable format.","title":"How Wireshark works"},{"location":"tools/wireshark.html#key-features","text":"Live capture and offline analysis Deep inspection of hundreds of protocols Multi-platform: Runs on Windows, Linux, macOS, and other Unix-like systems Powerful display filters Rich VoIP analysis Decryption support for many protocols","title":"Key features"},{"location":"tools/wireshark.html#command-line-examples","text":"While Wireshark is primarily a GUI application, it also offers command-line tools like tshark for terminal-based analysis.","title":"Command line examples"},{"location":"tools/wireshark.html#start-wireshark-from-command-line","text":"wireshark","title":"Start Wireshark from command line"},{"location":"tools/wireshark.html#capture-packets-on-a-specific-interface","text":"wireshark -i eth0 -k This command starts Wireshark, captures on the eth0 interface (-i eth0), and immediately starts capturing (-k).","title":"Capture packets on a specific interface"},{"location":"tools/wireshark.html#capture-with-a-filter","text":"wireshark -i eth0 -f \"port 80\" This captures only HTTP traffic on eth0.","title":"Capture with a filter"},{"location":"tools/wireshark.html#read-from-a-capture-file","text":"wireshark -r capture.pcap This opens a previously saved capture file.","title":"Read from a capture file"},{"location":"tools/wireshark.html#using-display-filters","text":"Display filters in Wireshark allow you to focus on specific types of traffic. Here are some common filters: Filter Purpose Syntax Show only HTTP traffic http Show traffic to/from a specific IP ip.addr == 192.168.1.1 Show TCP traffic on port 80 tcp.port == 80 Show all traffic except ARP and DNS !(arp or dns)","title":"Using display filters"},{"location":"tools/wireshark.html#analyzing-packets","text":"To analyze packets in Wireshark: Start a capture or open a capture file. Apply relevant display filters. Click on a packet in the packet list pane to view its details. Expand the protocol layers in the packet details pane to examine specific fields.","title":"Analyzing packets"},{"location":"tools/wireshark.html#tips-for-effective-use","text":"Use coloring rules to highlight important packets. Save frequently used filters as filter buttons. Use the \"Follow TCP Stream\" feature to reconstruct conversations. Leverage Wireshark's statistical tools for traffic analysis.","title":"Tips for effective use"}]}